# 신규 주문 등록 구조 구현

## 1. 개요

**목표:** 큐 방식으로 신규 주문(listCreated)을 인성1에 자동 등록하는 최소 구조 구현

**방식:**
- 기존 `StdResult_Status` 재사용 (새로운 타입 생성 안함)
- 간단명료한 에러 처리 (실패 시 앱 종료)
- switch 구조로 모든 케이스 명시

---

## 2. 구현 파일

### 2.1 InsungsAct_RcptRegPage.cs

**위치:** `Line 2086-2114`

**추가된 함수:**
```csharp
public async Task<StdResult_Status> CheckIsOrderAsync_AssumeKaiNewOrder(AutoAlloc item, CancelTokenControl ctrl)
{
    string kaiState = item.NewOrder.OrderState;

    switch (kaiState)
    {
        case "접수":
        case "취소":
        case "대기":
            // TODO: 실제 등록 로직 구현
            await Task.CompletedTask;
            return new StdResult_Status(StdResult.Success);

        case "배차":
        case "운행":
        case "완료":
        case "예약":
            return new StdResult_Status(StdResult.Fail,
                $"미구현 상태: {kaiState}",
                "CheckIsOrderAsync_AssumeKaiNewOrder_TODO",
                CommonVars.s_sLogDir);

        default:
            return new StdResult_Status(StdResult.Fail,
                $"알 수 없는 Kai 주문 상태: {kaiState}",
                "CheckIsOrderAsync_AssumeKaiNewOrder_800",
                CommonVars.s_sLogDir);
    }
}
```

**특징:**
- 입력: `AutoAlloc item`, `CancelTokenControl ctrl`
- 출력: `StdResult_Status` (Success/Fail)
- 직접 생성 방식 (로그/메시지 제어 가능)
- switch로 모든 상태 케이스 명시 (확장 용이)

---

### 2.2 NwInsung01.cs - Region 4

**위치:** `Line 310-366`

**수정 내용:**

```csharp
#region 4. Created Order 처리 (신규)
if (listCreated.Count > 0)
{
    Debug.WriteLine($"[{APP_NAME}] Region 4: 신규 주문 처리 시작 (총 {listCreated.Count}건)");

    // 역순으로 처리
    for (int i = listCreated.Count; i > 0; i--)
    {
        await ctrl.WaitIfPausedOrCancelledAsync();

        int index = i - 1;
        if (index < 0) break;

        AutoAlloc item = listCreated[index];
        Debug.WriteLine($"[{APP_NAME}]   [{i}/{listCreated.Count}] 신규 주문 처리: " +
                      $"KeyCode={item.KeyCode}, 상태={item.NewOrder.OrderState}");

        // 신규 주문 등록 시도
        StdResult_Status resultState = await m_Context.RcptRegPageAct.CheckIsOrderAsync_AssumeKaiNewOrder(item, ctrl);

        switch (resultState.Result)
        {
            case StdResult.Success:
                // 성공: 큐에 재적재 (다음 사이클에 관리 대상으로 분류됨)
                Debug.WriteLine($"[{APP_NAME}]   [{i}] 신규 주문 등록 성공: {item.KeyCode}");

                // NotChanged 상태로 변경
                item.StateFlag = PostgService_Common_OrderState.NotChanged;

                // 큐에 재적재 (다음 사이클에 listEtcGroup으로 분류)
                ExternalAppController.QueueManager.ReEnqueue(item, StdConst_Network.INSUNG1);
                break;

            case StdResult.Fail:
                // 신규 등록 실패는 치명적 에러 → 앱 종료
                Debug.WriteLine($"[{APP_NAME}]   [{i}] 신규 주문 등록 실패 (치명적): {item.KeyCode} - {resultState.sErr}");

                ErrMsgBox(
                    $"신규 주문 등록 실패 (앱 종료)\n주문: {item.KeyCode}\n\n{resultState.sErr}",
                    resultState.sPos);

                Environment.Exit(1);
                break;

            default:
                // 예상 못한 결과 → 앱 종료
                Debug.WriteLine($"[{APP_NAME}]   [{i}] 예상 못한 결과: {resultState.Result}");
                Environment.Exit(1);
                break;
        }
    }

    // Region 4 완료: listCreated 일괄 정리
    Debug.WriteLine($"[{APP_NAME}] Region 4 완료");
    listCreated.Clear();
}
#endregion
```

**처리 흐름:**
1. Success: StateFlag 변경 → QueueManager.ReEnqueue
2. Fail: ErrMsgBox 표시 → 앱 종료
3. 루프 종료 후 listCreated.Clear()

---

## 3. 데이터 흐름

### 이번 사이클
```
queueNewOrder (혼합)
  ↓ Region 3: TryDequeue
listCreated (StateFlag == Created)
  ↓ Region 4: CheckIsOrderAsync_AssumeKaiNewOrder
  ├─ Success → StateFlag = NotChanged → ReEnqueue
  └─ Fail → ErrMsgBox → Environment.Exit(1)

listCreated.Clear()
```

### 다음 사이클
```
queueNewOrder
  ↓ Region 3: TryDequeue
listEtcGroup (StateFlag == NotChanged)
  ↓ Region 5: 페이징 처리 (관리)
```

---

## 4. 주요 특징

### 4.1 기존 타입 재사용
- `StdResult_Status` 사용 (새로운 타입 생성 안함)
- `StdResult` enum 활용 (Success, Fail)
- 관리 용이

### 4.2 간단명료한 로직
- 성공: 큐 재적재 (다음 사이클에 관리)
- 실패: 앱 종료 (재시도 없음)
- 특별한 케이스 발견 시 확장 가능

### 4.3 큐 기반 사이클 분리
- Region 4: 신규만 (빠름, 첫 페이지)
- Region 5: 관리만 (느림, 페이징)
- 한 사이클에 한 번만 처리

---

## 5. 향후 확장 계획

### 5.1 TODO 항목
- `CheckIsOrderAsync_AssumeKaiNewOrder` 내부 실제 등록 로직 구현
  - 팝업창 열기
  - 주문 정보 입력
  - 저장 버튼 클릭

### 5.2 추가 가능한 기능
- 재시도 로직 (특정 에러만)
- 에러 타입별 처리 분기
- 배차/운행/완료/예약 상태 지원

---

## 6. 설계 의사결정

### 6.1 왜 StdResult_Status를 사용했는가?
- 백업에 `AutoAllocResult_State`가 있었으나 새로운 타입 생성 지양
- 기존 `StdResult_Status`로 충분히 표현 가능
- 관리 포인트 최소화

### 6.2 왜 실패 시 앱을 종료하는가?
- 신규 주문 등록은 반드시 성공해야 하는 중요한 작업
- 실패는 치명적 에러로 간주
- 일단 간단하게 → 특별한 케이스 발견 시 확장

### 6.3 왜 listCreated.Clear()를 루프 밖에서 하는가?
- 루프 중 RemoveAt 없음 → 안전
- 성공한 항목은 이미 큐에 재적재됨
- 코드 간결

### 6.4 왜 직접 생성 방식을 선택했는가?
- 헬퍼 함수(ErrMsgResult_Status)는 로그+메시지 자동
- 신규 구현 중이라 제어 필요
- 필요할 때만 로그/메시지 선택 가능

---

## 7. 테스트 시나리오

### 7.1 정상 케이스
1. 신규 주문(접수/대기/취소) 큐에 적재
2. Region 4에서 처리
3. Success 반환 → StateFlag 변경 → 큐 재적재
4. 다음 사이클에서 listEtcGroup으로 분류

### 7.2 에러 케이스
1. 미구현 상태(배차/운행 등) 주문 적재
2. Region 4에서 처리
3. Fail 반환 → ErrMsgBox → 앱 종료

---

## 8. 변경 이력

**2025-10-27**
- 신규 주문 등록 구조 최소 구현 완료
- InsungsAct_RcptRegPage.cs: CheckIsOrderAsync_AssumeKaiNewOrder 추가
- NwInsung01.cs: Region 4 호출 및 처리 로직 구현
- StdResult_Status 기반으로 설계
