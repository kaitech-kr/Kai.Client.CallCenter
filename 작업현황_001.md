# OFR 기능 복구 및 개선 작업 현황

## 작업 일자
2025-10-16

## 작업 개요
백업 파일에서 주석 처리된 OFR(Optical Font Recognition) 관련 함수들을 복구하고, 개선점을 파악하여 적용하는 작업 수행

## 주요 작업 내용

### 1. OfrWork_Commons.cs - 핵심 OFR 함수 복구
**파일 경로**: `D:\CodeWork\WithVs2022\KaiWork\Kai.Client\Kai.Client.CallCenter\Kai.Client.CallCenter\OfrWorks\OfrWork_Commons.cs`

**복구 함수**: `OfrImage_ExactDrawRelRectAsync`

**개선 사항**:
- 변수명 개선: `modelText` → `analyText`
- API 업데이트: `GetOfrModel_TextAnalysis_InExactBitmapFast` → `GetBitmapAnalysisFast`
- Helper 클래스 수정: `LocalCommon_OfrResult` → `CommonFuncs_OfrResult`
- ImageToMatchedTextWnd 다이얼로그 통합 (Debug 모드에서 수동 입력 지원)

### 2. OfrWork_Insungs.cs - 이미지 매칭 함수 복구
**파일 경로**: `D:\CodeWork\WithVs2022\KaiWork\Kai.Client\Kai.Client.CallCenter\Kai.Client.CallCenter\OfrWorks\OfrWork_Insungs.cs`

**복구 함수**: `OfrIsMatchedImage_DrawRelRectAsync`

**개선 사항**:
- 한글 에러 메시지 개선
- Helper 클래스 참조 수정
- Debug 모드 수동 입력 다이얼로그 추가

### 3. InsungsAct_RcptRegPage.cs - OFR 검증 추가
**파일 경로**: `D:\CodeWork\WithVs2022\KaiWork\Kai.Client\Kai.Client.CallCenter\Kai.Client.CallCenter\Networks\NwInsungs\InsungsAct_RcptRegPage.cs`

**추가 내용**:
- CommandBtn 3개 버튼(신규, 조회, 기사)에 대한 OFR 검증 로직 추가
- Non-blocking 방식 적용 (bMsgBox=false): 검증 실패 시 경고만 로그하고 실행 계속

### 4. OfrService.cs - 화면 캡처 함수 복구
**파일 경로**: `D:\CodeWork\WithVs2022\KaiWork\Kai.Common\Kai.Common.NetDll_WpfCtrl\Kai.Common.NetDll_WpfCtrl\NetOFR\OfrService.cs`

**복구 함수**:
- `CaptureScreen_InArea`
- `CaptureScreen_InRectangle`
- `CaptureScreenRect_InWndHandle` (2개 오버로드)

**개선 사항**:
- XML 문서 주석 추가
- 매개변수 유효성 검사 추가 (IntPtr.Zero, 윈도우 가시성 체크)
- Debug.WriteLine 로깅 추가
- Try-catch 예외 처리 추가
- 변수명 개선: `rcSon` → `rcTarget`
- 포맷팅 수정: `offset- offset` → `offset - offset`

### 5. ImageToMatchedTextWnd.xaml.cs - 수동 입력 다이얼로그 완전 복구
**파일 경로**: `D:\CodeWork\WithVs2022\KaiWork\Kai.Client\Kai.Client.CallCenter\Kai.Client.CallCenter\Windows\ImageToMatchedTextWnd.xaml.cs`

**복구 내용**:
- 전체 생성자 및 메서드 복구
- 속성명 수정: `bmpOrg` → `bmpExact`

**핵심 기능 - 다중 Threshold 저장 구현**:
```csharp
// 여러 threshold로 저장 (65~254)
byte minThreshold = 65;
byte maxThreshold = 254;
HashSet<string> savedHexStrings = new HashSet<string>(); // 중복 방지

for (byte threshold = minThreshold; threshold <= maxThreshold; threshold++)
{
    OfrModel_BitmapAnalysis analysis = OfrService.GetBitmapAnalysisFast(bmpExact, threshold);

    if (analysis != null && analysis.sHexArray != null &&
        analysis.trueRate > 0 && analysis.trueRate < 1)
    {
        // 중복된 HexString은 건너뛰기
        if (savedHexStrings.Contains(analysis.sHexArray)) continue;
        savedHexStrings.Add(analysis.sHexArray);

        // DB 저장
        TbText newTbText = new TbText { ... };
        await PgService_TbText.InsertRowAsync(newTbText);
    }
}
```

**다중 Threshold 저장 이유**:
- 대상 앱은 동일하지만, 실행 시스템이나 모니터에 따라 명도가 달라질 수 있음
- 테스트 결과: 190개 threshold → 약 100-113개 고유 HexString (40-47% 중복 제거)
- 다양한 환경에서의 인식률 향상을 위해 필요

**추가 개선**:
- `using System.Linq` 추가
- BtnExex_Click 메서드를 async로 변경
- 포괄적인 Debug 로깅 추가
- 저장 성공/실패 카운트 표시

## 발생한 오류 및 해결

### 오류 1: CS0103 - Helper 클래스 미발견
- **원인**: `LocalCommon_StdResult`, `LocalCommon_OfrResult` 클래스명 오류
- **해결**: `CommonFuncs_StdResult`, `CommonFuncs_OfrResult`로 수정
- **적용**: `using static` 지시문 추가

### 오류 2: CS0117 - API 이름 변경
- **원인**: `GetOfrModel_TextAnalysis_InExactBitmapFast` 함수가 없음
- **해결**: 신규 API `GetBitmapAnalysisFast`로 변경
- **배경**: API 현대화 작업으로 구형 타입 통합됨

### 오류 3: CS0117 - 함수 주석 처리
- **원인**: `CaptureScreenRect_InWndHandle` 함수들이 주석 처리됨
- **사용자 명확화**: "주석처리된 함수들은 개선점을 확인하기 위함임" - 사용 불가가 아닌 검토 대상
- **해결**: 주석 해제 및 개선 사항 적용

### 오류 4: CS1061 - 속성명 오류
- **원인**: `OfrModel_BitmapAnalysis`에 `bmpOrg` 속성 없음
- **해결**: 실제 속성명 `bmpExact`로 변경

## 테스트 결과
- **빌드**: 성공 (오류 없음)
- **테스트**: 양호

## 주요 기술 개념

### OFR (Optical Font Recognition)
- DB 기반 패턴 매칭 시스템으로 문자/이미지 인식
- TbText 테이블: Width, Height, HexStrValue, Threshold 정보 저장

### Threshold 기반 인식
- 모니터 밝기 차이를 고려한 다중 임계값 저장 (65-254)
- HashSet으로 중복 제거하여 약 100개 고유 패턴 저장

### OfrModel_BitmapAnalysis
- 기존 `OfrModel_BmpTextAnalysis` 타입들을 통합한 단일 모델

## 수정된 파일 목록
1. `Kai.Client.CallCenter\OfrWorks\OfrWork_Commons.cs`
2. `Kai.Client.CallCenter\OfrWorks\OfrWork_Insungs.cs`
3. `Kai.Client.CallCenter\Networks\NwInsungs\InsungsAct_RcptRegPage.cs`
4. `Kai.Common.NetDll_WpfCtrl\NetOFR\OfrService.cs`
5. `Kai.Client.CallCenter\Windows\ImageToMatchedTextWnd.xaml.cs`

## 향후 고려사항
- 실제 운영 환경에서 다양한 모니터/시스템 밝기에서의 인식률 모니터링
- Threshold 범위 조정 필요 시 minThreshold/maxThreshold 값 튜닝
- DB 저장 성능 최적화 (필요 시 일괄 삽입 검토)

## 비고
- 모든 주석 처리된 함수는 개선점 확인을 위한 것이며, 완전히 복구하여 사용 가능 상태로 변경됨
- Debug 모드에서 ImageToMatchedTextWnd 다이얼로그를 통해 수동으로 패턴 추가 가능
- Non-blocking OFR 검증으로 앱 실행 흐름에 영향 없이 검증 수행

---

# OFR 문자열 인식 함수 구현 (2025-10-16 계속)

## 작업 개요
컬럼 헤더 및 복합 문자열 인식을 위한 새로운 OFR 함수 구현 시작

## 주요 작업 내용

### 6. OfrWork_Commons.cs - OfrStr_ComplexCharSetAsync 함수 추가
**파일 경로**: `D:\CodeWork\WithVs2022\KaiWork\Kai.Client\Kai.Client.CallCenter\Kai.Client.CallCenter\OfrWorks\OfrWork_Commons.cs`

**새 함수**: `OfrStr_ComplexCharSetAsync`

**함수 시그니처**:
```csharp
public static async Task<OfrResult_TbCharSetList> OfrStr_ComplexCharSetAsync(
    Draw.Bitmap bmpOrg,
    Draw.Rectangle rcSpare,
    bool bSaveToTbText = false,  // 인식 성공 시 TbText 저장 여부
    bool bEdit = true,
    bool bWrite = true,
    bool bMsgBox = true)
```

**핵심 기능**:
- **Stage 1 (구현 완료)**: TbText 테이블에서 전체 문자열 매칭 시도
- **Stage 2-4 (TODO)**: RightSliding 알고리즘으로 fallback
  1. 델리게이트 함수 생성 (TbText 단일 문자 검색)
  2. RecognizeCharSetAsync_RightSliding 호출
  3. 결과를 OfrResult_TbCharSetList로 변환
  4. bSaveToTbText=true이고 완전 성공 시 TbText에 저장

**bSaveToTbText 매개변수 설계 이유**:
- **컬럼 헤더** (예: "오더번호"): `bSaveToTbText=false`
  - 앱마다 형식이 다양하여 재사용률이 낮음
  - 저장하지 않고 읽기만 수행
- **전화번호** (숫자만): SeqCharBitmapAsync 사용, 저장 안 함
- **사람 이름** (한글 포함): `bSaveToTbText=true`
  - 재사용 가능성이 높음
  - DB에 저장하여 향후 빠른 인식 지원

**구현 세부사항**:
1. rcSpare 영역 추출
2. 평균 밝기 계산
3. 전경 영역(foreground) 추출
4. 비트맵 분석 (GetBitmapAnalysisFast)
5. TrueRate 검증 (0 또는 1이면 실패)
6. TbText DB 조회
7. 성공 시 결과 반환, 실패 시 TODO Stage 2-4

**개선 사항**:
- 명확한 XML 문서 주석
- 비트맵 리소스 정리 (Dispose 호출)
- 포괄적인 에러 메시지
- Debug.WriteLine 로깅

## 아키텍처 분석

### OFR 문자 인식 전략 (4-Stage Fallback)
1. **Stage 1**: TbText 전체 매칭
   - 가장 빠른 방법
   - 이전에 학습된 전체 문자열 검색

2. **Stage 2**: Foreground/Background 분리 + TbChar 검색
   - (현재 TbChar는 deprecated)

3. **Stage 3**: RightSliding 알고리즘
   - 오른쪽→왼쪽으로 문자 검색
   - 첫 매칭 시 break (성능 최적화)
   - LeftSliding보다 DB 검색 횟수 적음

4. **Stage 4**: 특수 문자 치환
   - 인식 실패 영역은 '☒' 문자로 표시

### 새로운 Sliding 알고리즘 (Ofr_CharSet_Core.cs)
- **위치**: `Kai.Common.NetDll_WpfCtrl\NetOFR\Ofr_CharSet_Core.cs`
- **LeftSliding**: 왼쪽→오른쪽, Greedy (가장 큰 w값 선택)
- **RightSliding**: 오른쪽→왼쪽, Optimized (첫 매칭 시 break) ⭐ 권장
- **델리게이트 패턴**: `OfrCharSearchDelegate` - 앱별 DB 접근 추상화
- **결과 타입**: `OfrResult_Recognition` (strResult, SourceBitmap, CharRects)

## 현재 상태

### 구현 완료
- ✅ OfrStr_ComplexCharSetAsync Stage 1 (TbText 전체 매칭)
- ✅ 함수 시그니처 및 매개변수 설계
- ✅ 비트맵 처리 파이프라인 (rcSpare → Foreground → Analysis)
- ✅ bSaveToTbText 매개변수 추가

### 미구현 (TODO)
- ❌ Stage 2-4: RightSliding 알고리즘 통합
- ❌ OfrCharSearchDelegate 구현 (TbText 단일 문자 검색용)
- ❌ OfrResult_Recognition → OfrResult_TbCharSetList 변환
- ❌ bSaveToTbText 로직 구현
- ❌ InsungsAct_RcptRegPage.cs에 컬럼 헤더 읽기 로직 추가
- ❌ 실제 테스트 및 검증

## 기술적 결정 사항

### API 호환성 이슈
- `GetForeGroundDrawRectangle_FromColorBitmapRectFast`는 주석 처리됨
- **해결책**: rcSpare 영역을 먼저 추출한 후 `GetForeGroundDrawRectangle_FromColorBitmapFast` 사용

### 빌드 상태
- **의존성 빌드**: 성공
  - Kai.Common.StdDll_Common ✅
  - Kai.Common.NetDll_WpfCtrl ✅
  - Kai.Server.Main ✅
- **FormCtrl 프로젝트**: 리소스 관련 에러 (기존 이슈, 내 코드와 무관)

## 다음 단계
1. RightSliding 알고리즘 통합을 위한 델리게이트 함수 작성
2. 컬럼 헤더 읽기 로직 추가 (InsungsAct_RcptRegPage.cs)
3. 실제 데이터로 테스트
4. Stage 2-4 구현 및 통합

## 참고 코드 위치
- **Sliding 알고리즘**: `Kai.Common.NetDll_WpfCtrl\NetOFR\Ofr_CharSet_Core.cs`
  - Lines 29-362: `RecognizeCharSetAsync` (LeftSliding)
  - Lines 376-726: `RecognizeCharSetAsync_RightSliding` (권장)
- **결과 타입**: `Kai.Common.NetDll_WpfCtrl\NetOFR\OfrResults.cs`
  - Lines 15-42: `OfrCharSearchResult`
  - Lines 52: `OfrCharSearchDelegate`
  - Lines 63-142: `OfrResult_Recognition`

---

# RelChildRects 계산 구현 완료 (2025-10-18)

## 작업 개요
Datagrid 각 셀의 상대 좌표를 계산하는 RelChildRects 2차원 배열 구현 완료

## 구현 내용

### 1. InsungsAct_RcptRegPage.cs - RelChildRects 계산 로직 추가
**파일 경로**: `D:\CodeWork\WithVs2022\KaiWork\Kai.Client\Kai.Client.CallCenter\Kai.Client.CallCenter\Networks\NwInsungs\InsungsAct_RcptRegPage.cs`

**위치**: Lines 611-697

**핵심 구현**:
```csharp
// 4-1. 행 정보 계산 (Header + EmptyRow + DataRows)
List<OfrModel_TopHeight> listTH = new List<OfrModel_TopHeight>();

// 헤더 행
listTH.Add(new OfrModel_TopHeight(curRowTop + headerGab, headerHeight - (headerGab * 2)));

// Empty Row
curRowTop += m_FileInfo.접수등록Page_DG오더_headerHeight;
listTH.Add(new OfrModel_TopHeight(curRowTop + 1, dataRowHeight));

// Data Rows (28개)
curRowTop += m_FileInfo.접수등록Page_DG오더_emptyRowHeight;
for (int i = 0; i < m_FileInfo.접수등록Page_DG오더_dataRowCount; i++)
{
    listTH.Add(new OfrModel_TopHeight(curRowTop + 1, dataRowHeight));
    curRowTop += m_FileInfo.접수등록Page_DG오더_dataRowHeight;
}

// 4-2. RelChildRects 2차원 배열 생성 [열, 행]
m_RcptPage.DG오더_RelChildRects = new Draw.Rectangle[columns, rows];

// MainWnd 기준 상대좌표로 변환
for (int y = 0; y < rows; y++)
{
    for (int x = 0; x < columns; x++)
    {
        m_RcptPage.DG오더_RelChildRects[x, y] = new Draw.Rectangle(
            listLW[x].nLeft + rcDG_Rel.Left,    // MainWnd 기준 X
            listTH[y].nTop + rcDG_Rel.Top,      // MainWnd 기준 Y
            listLW[x].nWidth,
            listTH[y].nHeight
        );
    }
}

// 4-3. Background Brightness 계산
m_RcptPage.DG오더_nBackgroundBright = OfrService.GetBrightness_PerPixel(bmpDG, ptSampleRel);
```

### 2. 데이터 구조

**OfrModel_TopHeight** (`OfrModels.cs` Lines 110-130):
```csharp
public class OfrModel_TopHeight
{
    public int nTop { get; set; }      // Y 좌표
    public int nHeight { get; set; }   // 높이
}
```

**OfrModel_LeftWidth** (`OfrModels.cs` Lines 135-160):
```csharp
public class OfrModel_LeftWidth
{
    public int nLeft { get; set; }     // X 좌표
    public int nWidth { get; set; }    // 너비
}
```

**RelChildRects 구조**:
- 타입: `Draw.Rectangle[,]` (2차원 배열)
- 인덱스: `[열, 행]`
- 크기: `[20, 30]` (20개 컬럼 × 30개 행)
  - 행 0: 헤더
  - 행 1: Empty Row
  - 행 2-29: Data Rows (28개)

### 3. 좌표 시스템

**비트맵 좌표** → **MainWnd 기준 상대좌표**:
```csharp
// bmpDG는 Datagrid만 캡처한 비트맵 (원점 0,0)
// listLW[x].nLeft = 비트맵 내 X 좌표
// listTH[y].nTop = 비트맵 내 Y 좌표

// RelChildRects는 MainWnd 기준 상대좌표
Rectangle rcCell = new Rectangle(
    listLW[x].nLeft + rcDG_Rel.Left,  // MainWnd 기준으로 변환
    listTH[y].nTop + rcDG_Rel.Top,
    listLW[x].nWidth,
    listTH[y].nHeight
);
```

**첫 번째 컬럼 특수 처리**:
```csharp
if (x == 0)  // 순번 컬럼
{
    nLeft += 1;   // 1픽셀 안쪽으로
    nWidth -= 1;  // 너비 1픽셀 감소
}
```

### 4. 상수 값 (InsungsInfo_File.cs)

```csharp
접수등록Page_DG오더_headerHeight = 30;      // 헤더 높이
접수등록Page_DG오더_emptyRowHeight = 25;    // Empty Row 높이
접수등록Page_DG오더_dataRowHeight = 20;     // 데이터 행 높이
접수등록Page_DG오더_dataRowCount = 28;      // 데이터 행 개수
```

## 빌드 결과

- ✅ Kai.Common.StdDll_Common: 빌드 성공
- ✅ Kai.Common.NetDll_WpfCtrl: 빌드 성공
- ✅ Kai.Common.FrmDll_WpfCtrl: 빌드 성공
- ❌ Kai.Common.FrmDll_FormCtrl: 기존 리소스 이슈 (내 코드와 무관)
- ✅ **추가된 코드**: 컴파일 오류 없음

## 추가 구현: GetPixelBrightness 함수

### 문제 상황
- `GetBrightness_PerPixel` 함수가 주석 처리되어 있어 사용 불가

### 해결 방법 (리팩토링 원칙 적용)
**주석 해제하지 않고, 복사해서 개선점을 찾으면서 리팩토링**

**파일**: `OfrService.cs` Lines 1873-1921

**기존 함수의 문제점**:
1. ❌ 두 오버로드의 null 처리 반환값이 다름 (0 vs -1)
2. ❌ 범위 검사 없음 (x, y가 비트맵 범위 벗어날 수 있음)
3. ❌ XML 문서 주석 없음
4. ❌ Debug 로깅 없음
5. ❌ 그레이스케일 계산 공식이 표준이 아님 (0.3, 0.59, 0.11)

**개선된 새 함수**:
```csharp
/// <summary>
/// 비트맵의 특정 픽셀에서 밝기를 계산합니다 (그레이스케일 변환 공식 사용)
/// </summary>
/// <param name="bmp">대상 비트맵</param>
/// <param name="x">X 좌표</param>
/// <param name="y">Y 좌표</param>
/// <returns>밝기 값 (0-255), 오류 시 0</returns>
public static byte GetPixelBrightness(Draw.Bitmap bmp, int x, int y)
{
    // 1. Null 검사
    if (bmp == null)
    {
        Debug.WriteLine($"[OfrService] GetPixelBrightness 실패: bmp=null");
        return 0;
    }

    // 2. 범위 검사
    if (x < 0 || x >= bmp.Width || y < 0 || y >= bmp.Height)
    {
        Debug.WriteLine($"[OfrService] GetPixelBrightness 실패: 범위 초과 ({x}, {y}), 비트맵 크기=({bmp.Width}, {bmp.Height})");
        return 0;
    }

    Draw.Color color = bmp.GetPixel(x, y);

    // 3. ITU-R BT.601 표준 그레이스케일 공식
    // Y = 0.299*R + 0.587*G + 0.114*B (기존: 0.3, 0.59, 0.11)
    byte brightness = (byte)((color.R * 0.299) + (color.G * 0.587) + (color.B * 0.114));

    Debug.WriteLine($"[OfrService] GetPixelBrightness: ({x}, {y}) = RGB({color.R}, {color.G}, {color.B}) → {brightness}");

    return brightness;
}

// Point 오버로드
public static byte GetPixelBrightness(Draw.Bitmap bmp, Draw.Point pt)
{
    return GetPixelBrightness(bmp, pt.X, pt.Y);
}
```

**개선 사항**:
- ✅ XML 문서 주석 추가
- ✅ 매개변수 유효성 검사 (null, 범위)
- ✅ 일관된 오류 반환값 (0)
- ✅ Debug 로깅 추가 (RGB 값 포함)
- ✅ ITU-R BT.601 표준 공식 사용 (0.299, 0.587, 0.114)
- ✅ 반환 타입 변경: `int` → `byte` (밝기는 0-255 범위)
- ✅ 명확한 함수명: `GetBrightness_PerPixel` → `GetPixelBrightness`

## Debug 로그 출력 예상

```
[InsungsAct_RcptRegPage] 헤더 행 추가: Top=7, Height=16
[InsungsAct_RcptRegPage] Empty Row 추가: Top=31, Height=18
[InsungsAct_RcptRegPage] Data Rows 추가 완료: 총 28개
[InsungsAct_RcptRegPage] RelChildRects 생성 완료: 20열 x 30행
[InsungsAct_RcptRegPage] Background Brightness: 245
[InsungsAct_RcptRegPage] SetDG오더RectsAsync 완료
```

## 활용 방법

**셀 클릭 예시**:
```csharp
// [0, 1] = 첫 번째 컬럼, 두 번째 행 (Empty Row)
Draw.Rectangle rcCell = m_RcptPage.DG오더_RelChildRects[0, 1];
Draw.Point ptCenter = new Draw.Point(
    rcCell.Left + rcCell.Width / 2,
    rcCell.Top + rcCell.Height / 2
);
await Std32Mouse_Post.MousePostAsync_ClickLeft(m_RcptPage.DG오더_hWnd, ptCenter);
```

**셀 데이터 읽기 예시**:
```csharp
// [3, 2] = 주문번호 컬럼, 첫 번째 데이터 행
Draw.Rectangle rcCell = m_RcptPage.DG오더_RelChildRects[3, 2];
Draw.Bitmap bmpCell = OfrService.CaptureScreenRect_InWndHandle(
    m_Main.TopWnd_hWnd,
    rcCell
);
string orderNo = await OfrStr_SeqCharAsync(bmpCell, ...);
```

## 향후 작업

1. 실제 환경에서 RelChildRects 좌표 검증
2. 셀 데이터 읽기 테스트 (OFR 함수 활용)
3. 셀 클릭 테스트 (마우스 이벤트)
4. 스크롤 처리 로직 추가 (가시 영역 밖 데이터 접근)

## 참고 코드

**백업 파일**: `InsungsAct_ReceiptPage_Datagrid.cs` Lines 177-200
**사용 예시**: `InsungsAct_ReceiptPage.cs` (주석 처리된 코드 다수)

---

# OFR 설계 원칙 및 아키텍처 (2025-10-17)

## 작업 개요
단음소 문자열 인식 함수(`OfrStr_SeqCharAsync`, `OfrStr_SeqWordAsync`) 구현 및 설계 원칙 정립

## 핵심 설계 원칙

### 1. Threshold(임계값) 재사용 원칙 ⭐⭐⭐

#### 원칙
- **한 텍스트 안에서는 임계값이 같거나 비슷함**
- 같은 폰트, 같은 렌더링 환경에서 생성된 문자들은 동일한 밝기 특성을 가짐

#### 구현 방식
```csharp
// ❌ 잘못된 방식 (매번 계산)
for (int i = 0; i < listStartEnd.Count; i++)
{
    Bitmap bmpChar = ...;
    byte threshold = GetAverageBrightness_FromColorBitmapFast(bmpChar); // 중복 계산!
    GetBitmapAnalysisFast(bmpChar, threshold);
}

// ✅ 올바른 방식 (한 번만 계산)
byte threshold = GetAverageBrightness_FromColorBitmapFast(bmpSpare); // 전체 영역에서 1번

for (int i = 0; i < listStartEnd.Count; i++)
{
    Bitmap bmpChar = ...;
    GetBitmapAnalysisFast(bmpChar, threshold); // 재사용
}
```

#### 적용 대상
- `OfrStr_SeqCharCore` (단음소용)
- `OfrStr_ComplexCharSetAsync` (다음소용, Stage 2-4)

### 2. 함수 계층 구조 원칙

#### 2-1. 상위 함수 (2개 분류)
```
┌─────────────────────────────────────┐
│ 단음소용 함수                        │
│ - OfrStr_SeqWordAsync (Stage 1+2)   │
│ - OfrStr_SeqCharAsync (Stage 2만)   │
└─────────────────────────────────────┘
         │
         └─ OfrStr_SeqCharCore (private)
            ├─ threshold 한 번 계산
            └─ 하위 함수들에 전달

┌─────────────────────────────────────┐
│ 다음소용 함수 (범용)                 │
│ - OfrStr_ComplexCharSetAsync      │
└─────────────────────────────────────┘
         │
         ├─ Stage 1: TbText 전체 매칭
         └─ Stage 2-4: RightSliding
            ├─ threshold 한 번 계산
            └─ 하위 함수들에 전달
```

**책임**:
- Threshold 계산 (1번만)
- 전체 비즈니스 로직
- 결과 저장 (TbText)

#### 2-2. 하위 함수 (재사용 가능)
```csharp
// 모든 하위 함수는 threshold를 매개변수로 받음
GetBitmapAnalysisFast(Bitmap bmp, byte threshold)
GetForeGroundDrawRectangle_FromColorBitmapFast(Bitmap bmp, byte threshold, int offset)
GetStartEndList_FromColorBitmap(Bitmap bmp, byte threshold, Rectangle rcForeground)
GetIndexRect_FromColorBitmapByIndex(Bitmap bmp, byte threshold, ...)
```

**책임**:
- Threshold를 외부에서 받음
- 순수 기능 구현 (계산만)
- **단독 사용 가능** (다른 함수에서도 호출 가능)

### 3. 범용성 원칙 (다음소용 함수의 역할) ⭐⭐⭐

#### 문제 상황
```csharp
string colHeader = "???"; // 이게 "No"(영문)인지 "상태"(한글)인지 모름
// 어떤 함수를 사용해야 하지?
```

#### 해결책: 다음소용 함수는 단음소도 처리
```csharp
// OfrStr_ComplexCharSetAsync (범용 함수)
// - 한글 + 영문 + 숫자 모두 처리 가능
// - 느리지만 안전함

Stage 1: TbText 전체 매칭 (모든 타입)
└─ 실패 시 ↓

Stage 2-4: RightSliding + OfrCharSearchDelegate
└─ Delegate에서 TbCharBackup 검색 (모든 문자)
   ⚠️ TbChar는 현재 rebuilding 작업 중이라 사용 불가
   ⚠️ TbCharBackup은 임시 백업 테이블 (rebuilding 완료 후 삭제 예정)
```

**델리게이트 구현 예시**:
```csharp
OfrCharSearchDelegate searchDelegate = async (Bitmap bmp, byte threshold) =>
{
    List<OfrCharSearchResult> results = new List<OfrCharSearchResult>();

    OfrModel_BitmapAnalysis analysis = GetBitmapAnalysisFast(bmp, threshold);

    // 현재: TbCharBackup만 검색 (모든 문자 - 다음소 + 단음소)
    var backupResult = await PgService_TbCharBackup.SelectRowByBasicAsync(
        analysis.nWidth, analysis.nHeight, analysis.sHexArray);
    if (backupResult != null)
        results.Add(new OfrCharSearchResult(backupResult.Character, ...));

    // TODO: TbChar rebuilding 완료 후
    //   - TbChar.SelectRowByBasicAsync로 변경
    //   - TbCharBackup 관련 코드 삭제

    return results; // RightSliding이 최적 선택
};

RecognizeCharSetAsync_RightSliding(bmp, threshold, searchDelegate);
```

### 4. 함수 사용 전략

#### 확실히 알 때 (최적화)
```csharp
// 영문, 숫자만 (예: "No", "123", "OK")
await OfrStr_SeqCharAsync(bmp, rcSpare, ...); // Stage 2만 - 빠름

// 반복되는 단음소 단어 (예: "No", "Yes")
await OfrStr_SeqWordAsync(bmp, rcSpare, ...); // Stage 1+2 - 캐싱
```

#### 모호하거나 복잡할 때 (안전)
```csharp
// 한글 포함, 타입 불명 (예: "상태", "접수완료", "홍길동")
await OfrStr_ComplexCharSetAsync(bmp, rcSpare, ...); // Stage 1+2-4 - 범용
```

## 구현 완료된 함수

### OfrStr_SeqCharCore (private)
**파일**: `OfrWork_Commons.cs` Lines 268-472

**기능**:
- Stage 1 (optional): TbText 전체 매칭
- Stage 2: GetStartEndList → TbCharBackup 단일 문자 인식
- Threshold 한 번 계산 후 재사용
- 완전 성공 시 TbText 자동 저장

**매개변수**:
```csharp
private static async Task<OfrResult_TbCharSetList> OfrStr_SeqCharCore(
    Draw.Bitmap bmpOrg,
    Draw.Rectangle rcSpare,
    bool bUseTbTextStage1,  // ⭐ Stage 1 사용 여부
    bool bEdit = true,
    bool bWrite = true,
    bool bMsgBox = true)
```

### OfrStr_SeqWordAsync (public)
**파일**: `OfrWork_Commons.cs` Lines 486-494

**용도**: 반복되는 단음소 단어 (예: "No", "OK", "Yes")
**특징**: Stage 1 활성화 (TbText 캐싱)

### OfrStr_SeqCharAsync (public)
**파일**: `OfrWork_Commons.cs` Lines 508-516

**용도**: 가변 단음소 데이터 (예: 전화번호, 숫자)
**특징**: Stage 1 건너뜀 (매번 새로운 값)

## 테스트 결과

### "No" 컬럼 헤더 테스트 (2025-10-17)
```
[OfrService] GetStartEndList: 검출된 문자 영역 수=2
[OfrStr_SeqCharCore] Step 3: 문자 영역 수=2
[OfrStr_SeqCharCore] 문자[0] 인식 성공: N
[OfrStr_SeqCharCore] 문자[1] 인식 성공: o
[OfrStr_SeqCharCore] 최종 결과: No
[OfrStr_SeqCharCore] TbText 저장 성공: No
[InsungsAct_RcptRegPage] 컬럼[0] OFR 성공 (SeqChar): 'No'
```

**검증 완료**:
- ✅ GetStartEndList_FromColorBitmap (문자 경계 검출)
- ✅ TbCharBackup 단일 문자 인식 (N, o 개별 검색)
- ✅ 자동 TbText 저장 (학습 기능)
- ✅ Threshold 재사용 (성능 최적화)

## 향후 작업 (TODO)

### 1. Threshold 중복 계산 제거
**위치**: `OfrStr_SeqCharCore` Line 393
**수정 필요**:
```csharp
// 현재 (잘못됨)
byte byteCharBrightness = GetAverageBrightness_FromColorBitmapFast(bmpChar);
GetBitmapAnalysisFast(bmpChar, byteCharBrightness);

// 수정 후 (올바름)
GetBitmapAnalysisFast(bmpChar, byteAvgBrightness); // 전체 threshold 재사용
```

### 2. OfrStr_ComplexCharSetAsync Stage 2-4 구현
**필요 사항**:
- RightSliding 알고리즘 통합
- OfrCharSearchDelegate 구현 (TbChar + TbCharBackup)
- OfrResult_Recognition → OfrResult_TbCharSetList 변환
- bSaveToTbText 로직 구현

### 3. 함수명 통일성 개선 (선택사항)
- `OfrImage_ExactDrawRelRectAsync` → `OfrStr_FromTbTextAsync`?

## 중요 참고사항

### DB 저장 vs 인식 비교
- **저장 시** (ImageToMatchedTextWnd): threshold 65~254 (190개) → 약 100개 고유 패턴
- **인식 시** (OfrStr_SeqCharCore): 현재 평균 밝기 1번 계산 → 해당 threshold로 1번 검색

### 왜 이렇게 설계했는가?
1. **저장 시 다중 threshold**: 다양한 모니터/시스템 환경 대응
2. **인식 시 단일 threshold**: 현재 환경에 최적화, DB에 다중 패턴 있어 매칭 가능
3. **Threshold 재사용**: 같은 텍스트 내 문자들은 동일 환경이므로 재사용

### 주의사항
- 다음소용 함수(`OfrStr_ComplexCharSetAsync`)는 반드시 단음소도 처리 가능해야 함
- 하위 함수는 threshold를 매개변수로 받아 단독 사용 가능하도록 설계
- 상위 함수는 threshold를 한 번만 계산하고 재사용

---

# OFR 단음소 함수 구현 완료 (2025-10-17 오후)

## 작업 완료 항목

### 1. OfrStr_SeqCharCore Threshold 최적화 ✅
**위치**: `OfrWork_Commons.cs` Lines 268-472

**수정 내용**:
- Line 394: 각 문자 인식 시 threshold 재사용 (중복 계산 제거)
- Line 447: TbText 저장 시 threshold 재사용
- Stage 1은 정확도를 위해 2회 계산 유지 (전체 영역 + 전경 영역)

### 2. OfrStr_ComplexCharSetAsync 수정 ✅
**위치**: `OfrWork_Commons.cs` Lines 118-252

**변경 사항**:
- 함수명 변경: `OfrStr_FromComplexBitmapAsync` → `OfrStr_ComplexCharSetAsync`
- Line 195: `PgService_TbChar` → `PgService_TbCharBackup` (TbChar rebuilding 중)
- Stage 1+2-4 모두 구현 완료 (테스트 미완)

### 3. 컬럼 헤더 OFR 테스트 ✅
**위치**: `InsungsAct_RcptRegPage.cs` Lines 512-607

**테스트 결과** ("No" 컬럼):
```
[OfrService] GetStartEndList: 검출된 문자 영역 수=2
[OfrStr_SeqCharCore] 문자[0] 인식 성공: N
[OfrStr_SeqCharCore] 문자[1] 인식 성공: o
[OfrStr_SeqCharCore] 최종 결과: No
[OfrStr_SeqCharCore] TbText 저장 성공: No
[InsungsAct_RcptRegPage] 컬럼[0] OFR 성공 (SeqChar): 'No'
```

**현재 상태**:
- 첫 번째 컬럼만 테스트 중 (Line 518-522)
- `OfrStr_SeqCharAsync` 사용 (Stage 2만)
- TODO: OfrStr_ComplexCharSetAsync 검증 후 모든 컬럼에 적용

## 주요 설계 결정

### 컬럼 헤더 OFR 전략
**초기 계획**: 컬럼별 함수 분리
- "No" (영문) → `OfrStr_SeqWordAsync`
- "상태" 등 (한글) → `OfrStr_ComplexCharSetAsync`

**최종 결정**: 단일 함수 사용
- 모든 컬럼 → `OfrStr_ComplexCharSetAsync` (범용 함수)
- 이유: 코드 단순화, OfrStr_ComplexCharSetAsync는 단음소도 처리 가능

### 메모리 관리
**Datagrid 캡처 방식**:
- 초기화 시: 한 번 캡처 후 로컬 변수로 사용 (finally에서 Dispose)
- 실제 운영 시: 매번 새로 캡처 필요 (데이터 실시간 변경)
- 멤버 변수 저장 ❌ (메모리 누수, 오래된 데이터 참조)

## 다음 작업 (TODO)

### 1. RelChildRects 계산 (다음 세션)
**목적**: Datagrid 각 셀의 상대 좌표 계산
**구조**: `Draw.Rectangle[,]` (2차원 배열 - [행, 열])

### 2. OfrStr_ComplexCharSetAsync 검증
- Stage 2-4 (RightSliding) 테스트
- 모든 컬럼 헤더에 적용
- TbCharBackup → TbChar 마이그레이션 (rebuilding 완료 후)

## 파일 수정 이력 (2025-10-17)
1. `OfrWork_Commons.cs` - Threshold 최적화, 함수명 변경
2. `InsungsAct_RcptRegPage.cs` - 컬럼 헤더 OFR 테스트 추가
3. `작업현황_001.md` - 설계 원칙 및 아키텍처 문서화