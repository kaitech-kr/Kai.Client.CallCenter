# 작업 기록 통합 문서

**최종 업데이트**: 2025-11-10

---

## 📌 현재 작업 상태

### 🔨 오늘 작업 (2025-11-10)

#### UpdateOrderStateOnlyAsync 함수 구현
**파일**: `InsungsAct_RcptRegPage.UI.cs`

**배경**:
- 기존 UpdateOrderInPopupAsync는 필드 업데이트 → 상태 버튼 클릭 순서
- 요금 영역 업데이트 실패 시 early return → 상태 버튼까지 도달 못함
- 예: "완료→취소" 전환 시 요금 입력 실패 → 상태 변경 안 됨

**구현 내용** (Line 1675-1771):
```csharp
/// <summary>
/// 팝업 내 주문 상태만 업데이트 (필드는 건드리지 않음)
/// </summary>
private async Task<CommonResult_AutoAllocProcess> UpdateOrderStateOnlyAsync(
    string wantState, AutoAllocModel item, CommonResult_AutoAllocDatagrid dgInfo,
    bool useRepeat, CancelTokenControl ctrl)
{
    // 1. 팝업 열기
    // 2. 상태 버튼 클릭
    // 3. 팝업 닫기 (저장)
}
```

**핵심 로직**:
1. 팝업 열기 → OpenEditPopupAsync
2. 상태 버튼만 클릭 (필드 업데이트 없음)
3. shouldSave: true로 저장
4. 취소 상태면 SuccessAndDestroy, 그 외는 SuccessAndReEnqueue

**테스트 결과** (Log..txt):
```
[INSUNG1] UpdateOrderStateOnlyAsync 시작
  - wantState: '취소'
[INSUNG1] 팝업 열기 성공
[INSUNG1] 상태 버튼 클릭 완료: 취소
[INSUNG1] 저장 버튼 클릭
[INSUNG1] 윈도우 정상 닫힘 확인
[INSUNG1] 저장 성공 - 팝업 닫힘
```

**발견된 문제**:
- ✅ 로그상으로는 모든 단계 성공
- ❌ 실제로는 저장이 안 됨 (상태가 변경되지 않음)
- **원인 추정**: 상태 버튼 클릭 후 실제로 UI에서 상태가 바뀌었는지 확인하는 로직 없음

**내일 작업**:
- [ ] 인성 앱 팝업에 상태 표시 라벨 찾기
- [ ] 상태 버튼 클릭 후 GetWindowText/GetWindowCaption으로 상태 확인
- [ ] 상태가 실제로 바뀌었는지 검증 로직 추가
- [ ] 바뀌지 않았으면 재시도 또는 에러 반환

---

## ✅ 완료된 작업

### 1. 접수등록 - 요금 및 오더메모 입력 (2025-10-29)
**파일**: `InsungsAct_RcptRegPage.cs`

**구현 내용**:
- 요금 입력 (기본요금, 추가금액, 할인금액, 탁송료)
  - 보안상 키보드 시뮬레이션만 사용 (SetWindowText 불가)
  - `ResgistAndVerify요금Async` 함수로 입력 및 검증
- 오더메모 입력 (형식: `{KeyCode}/{OrderMemo}`)
  - `WriteAndVerifyEditBoxAsync` 사용

**핵심 함수**:
- `ResgistAndVerify요금Async` (Line 3739-3765): 요금 필드 입력/검증, 3회 재시도
- `WriteAndVerifyEditBoxAsync` (Line 3011-3071): EditBox 입력/검증

### 2. 접수등록 - 첫 로우 선택 검증 (2025-10-30)
**파일**: `InsungsAct_RcptRegPage.cs`

**구현 내용**:
- 첫 로우 선택 검증 (중심 라인 평균 밝기 방식)
  - 선택 시 반전되어 어두워짐 → `평균 밝기 < 배경 밝기 - 10`
- 첫 로우 클릭 함수 개선 (클릭 후 검증 및 재시도)

**핵심 함수**:
- `VerifyFirstRowSelectedAsync` (Line 2541-2603): 중심 라인 평균 밝기로 선택 검증
- `ClickFirstRowAsync` (Line 2482-2539): 클릭 후 검증, 실패 시 재시도

### 3. Datagrid 배경 밝기 측정 및 Region 5-1, 5-3 개선 (2025-11-02)
**파일**:
- `InsungsAct_RcptRegPage.cs`
- `NwInsung01.cs`

**구현 내용**:
1. **배경 밝기 측정 위치 수정**
   - Empty Row의 샘플 포인트를 (3,3)에서 (8,8)로 변경
   - 측정값이 211에서 255로 개선되어 정확도 향상
   - `InsungsAct_RcptRegPage.cs` Line 832

2. **Region 5-1: 총계 읽기 로직 개선**
   - 한 번만 시도하던 로직을 백업 코드처럼 반복 구조로 변경
   - 조회버튼 클릭과 총계 읽기를 `c_nRepeatNormal`회 반복
   - 실패 시 `c_nWaitNormal` 대기 후 재시도
   - `NwInsung01.cs` Line 376-400

3. **Region 5-3: 유효 로우 체크 로직 완성**
   - 페이지별 유효 로우 갯수 측정 구현
   - 밝기 측정 위치: `rects[0, y].Right, rects[0, y].Top + 6`
   - 임계값: `배경 밝기 - 1`
   - 밝기가 임계값 미만이면 유효 로우로 카운트
   - `NwInsung01.cs` Line 465-479

### 4. 페이지 검증 및 자동 조정 (2025-11-03)
**파일**:
- `InsungsAct_RcptRegPage.cs`
- `InsungsInfo_File.cs`
- `OfrWork_Commons.cs`
- `NwInsung01.cs`

**구현 내용**:
1. **GetExpectedFirstRowNum 함수** (InsungsAct_RcptRegPage.cs Line 2805-2828)
   - 페이지별 예상 첫 로우 번호 계산 (0-based 인덱스)
   - 마지막 페이지 특수 처리 (나머지 행 계산)
   - public static으로 선언 → 인성1, 인성2 공통 사용

2. **ReadFirstRowNumAsync 함수** (InsungsAct_RcptRegPage.cs Line 2830-2865)
   - OFR로 번호 컬럼(x=0) 실제 첫 번호 읽기
   - bEdit 매개변수로 대화상자 제어 (기본값: false)
   - y=2부터 순차적으로 OFR 시도

3. **VerifyAndAdjustPageAsync 함수** (InsungsAct_RcptRegPage.cs Line 2867-2943)
   - 페이지 검증 및 자동 조정 (재시도 3회)
   - 최소 클릭 최적화: rowClicks > 14이면 역방향 스크롤
   - 페이지/로우 스크롤 구분
   - public 메서드 → 인성1, 인성2 공통 사용

4. **OfrStr_SeqCharAsync 개선** (OfrWork_Commons.cs Line 282, 339)
   - bEdit 매개변수 추가 (기본값: true)
   - `if (bEdit && s_bDebugMode)` 조건 추가

5. **상수 변경** (InsungsInfo_File.cs Line 129)
   - `접수등록Page_DG오더_dataRowCount`를 const로 변경

### 5. 페이지 캡처 및 주문번호 OFR 구현 (2025-11-03)
**파일**:
- `InsungsAct_RcptRegPage.cs`
- `NwInsung01.cs`

**구현 내용**:
1. **GetValidRowCountAsync 함수** (InsungsAct_RcptRegPage.cs Line 2952-2981)
   - 캡처된 페이지 이미지에서 유효 로우 갯수 측정
   - 밝기 측정으로 실제 데이터 유무 확인
   - 임계값: 배경 밝기 - 1
   - StdResult_Int 반환 (에러 처리 포함)

2. **GetRowSeqnoAsync 함수** (InsungsAct_RcptRegPage.cs Line 2983-3033)
   - 캡처된 페이지 이미지에서 특정 로우의 주문번호 읽기
   - GetBitmapInBitmapFast로 영역 crop
   - bInvertRgb 매개변수로 선택된 행 RGB 반전 처리
   - OfrStr_SeqCharAsync로 주문번호 인식
   - StdResult_String 반환

3. **페이지 캡처 및 처리** (NwInsung01.cs Line 447-514)
   - 페이지별 데이터그리드 전체 캡처 (재시도 3회)
   - try-finally로 Bitmap 안전 해제
   - 유효 로우 갯수 얻기
   - 마지막 페이지 startIndex 자동 계산
   - 첫 페이지 첫 로우 자동 선택
   - 로우별 주문번호 OFR 및 Debug 출력

**주요 개선점**:
- 페이지당 1회 캡처로 성능 최적화 (셀마다 캡처 X)
- 마지막 페이지 빈 로우 자동 건너뜀
- 선택된 행 RGB 반전 자동 처리
- try-finally로 메모리 누수 방지

### 6. OFR 함수 오버로드 패턴 적용 및 코드 간소화 (2025-11-04)
**파일**:
- `OfrWork_Commons.cs`
- `InsungsAct_RcptRegPage.cs`
- `OfrService.cs` (Kai.Common.NetDll_WpfCtrl)

**구현 내용**:

1. **OfrStr_SeqCharAsync 오버로드 추가** (OfrWork_Commons.cs Line 390-415)
   - 파라미터: `(Draw.Bitmap bmpPage, Draw.Rectangle rect, bool bInvertRgb, bool bEdit = true)`
   - crop + RGB 반전 처리 후 기존 오버로드 호출
   - 중복 코드 제거로 코드 간소화

2. **OfrStr_ComplexCharSetAsync 오버로드 구조 생성** (OfrWork_Commons.cs)
   - **기본 오버로드** (Line 420-432): `(Draw.Bitmap bmpSource, bool bInvertRgb, bool bEdit = true)`
     - RGB 반전 처리 후 원본 함수 호출
     - TODO: 구현 필요 (원본 함수와 연동)
   - **OfrStr_ComplexCharSetAsync2** (Line 442-468): `(Draw.Bitmap bmpPage, Draw.Rectangle rect, bool bInvertRgb, bool bEdit = true)`
     - crop + RGB 반전 후 기본 오버로드 호출
     - OfrStr_SeqCharAsync와 동일한 패턴
   - **원본 함수** (Line 481~): `(Draw.Bitmap bmpOrg, Draw.Rectangle rcSpare, bool bSaveToTbText, bool bEdit, bool bWrite, bool bMsgBox)`
     - 기존 Stage 1-4 OFR 로직 유지

3. **InvertBitmap을 OfrService로 이동** (OfrService.cs Line 1135-1175)
   - 이유: InsungsAct_RcptRegPage → OfrWork_Commons 접근 불가
   - RGB 반전 로직: `dstBytes[i] = (byte)(255 - srcBytes[i])`
   - 재사용성 개선: 공통 유틸리티 레이어로 이동

4. **함수 간소화** (InsungsAct_RcptRegPage.cs)
   - **GetRowSeqnoAsync** (Line 2991-2995): 40+ lines → 3 lines
   - **GetRowStatusAsync** (Line 2956-2960): 40+ lines → 3 lines

**핵심 개선점**:
- 중복 코드 제거: crop + RGB 반전 로직을 오버로드로 통합
- 함수 간소화: 40+ lines → 3 lines
- 재사용성 개선: InvertBitmap을 공통 레이어로 이동
- 일관된 패턴: OfrStr_SeqCharAsync와 동일한 오버로드 구조

**커밋**: `7fc974b` - refactor: OFR 함수 오버로드 패턴 적용 및 코드 간소화

### 7. SignalR 주문 업데이트 처리 로직 개선 (2025-11-06)
**파일**:
- `ExternalAppController.cs`
- `QueueController.cs`
- `NwInsung01.cs`
- `InsungsAct_RcptRegPage.cs`

**구현 내용**:

1. **StateFlag 비트 연산 처리** (NwInsung01.cs Line 574-612)
   - 문제: switch 문으로는 비트 플래그(Updated_Status, Updated_Etc) 처리 불가
   - 해결: if-else chain으로 변경 + 비트 AND 연산자 사용

2. **상태 문자열 파싱** (NwInsung01.cs Line 567)
   - 문제: 인성 앱 상태가 "접수[1]", "접수[2]" 형식인데 switch는 "접수"만 체크
   - 해결: Substring(0, 2)로 앞 2글자만 추출

3. **큐 효율성 개선** (ExternalAppController.cs Line 185-218, 380-386)
   - 문제: SignalR 업데이트 시 4개 큐 모두 검색
   - 해결: GetTargetQueues() 함수로 차량 타입별 관련 큐만 검색

4. **재적재 로직 수정** (NwInsung01.cs Line 607-610)
   - 문제: 업데이트 성공 후 기존 StateFlag로 재적재 → 무한 루프 가능성
   - 해결: NotChanged 플래그로 재적재하여 계속 모니터링

5. **취소 상태 비적재 처리** (InsungsAct_RcptRegPage.cs Line 3978-3990, 3734-3736)
   - 문제: 취소 상태 전환 후에도 계속 큐에서 모니터링됨
   - 해결: wantState == "취소" 체크하여 SuccessAndComplete 반환

**핵심 개선점**:
- StateFlag 비트 연산으로 모든 업데이트 플래그 처리 가능
- 상태 문자열 파싱으로 인성 앱 형식 대응
- 큐 검색 최적화로 성능 향상 (4개 → 2개)
- NotChanged 플래그로 무한 루프 방지
- 취소 상태 자동 비적재로 불필요한 모니터링 제거

**커밋**: `45bf78c` - fix: SignalR 주문 업데이트 처리 로직 개선

### 8. Insung 주문 상태 관리 함수 구현 (2025-11-07)
**파일**:
- `InsungsAct_RcptRegPage.cs`
- `NwInsung01.cs`
- `AutoAllocModel.cs`

**구현 내용**:

1. **CheckIsOrderAsync_InsungOrderManage 메인 함수** (InsungsAct_RcptRegPage.cs Line 2216)
   - Insung 앱 상태 변화 모니터링 (NotChanged 상황 처리)
   - Insung 상태를 primary switch로 분기
   - 각 Insung 상태별 handler 함수 호출 (중첩 switch 방지)
   - 로그 기반 골격 구현 (DB 업데이트/앱 취소는 TODO)

2. **Insung 상태별 Handler 함수들** (InsungsAct_RcptRegPage.cs)
   - **InsungOrderManage_접수Or배차Async** (Line 2247): 접수/배차 상태 통합 처리
   - **InsungOrderManage_운행Async** (Line 2286): 운행 상태 + 40초 타이머
   - **InsungOrderManage_완료Async** (Line 2348): 완료 상태 처리
   - **InsungOrderManage_취소Async** (Line 2393): 취소 상태 처리

3. **AutoAllocModel에 RunStartTime 추가** (AutoAllocModel.cs Line 48-52)
   - 인성 "운행" 상태 진입 시간 추적 (40초 타이머용)

4. **NwInsung01.cs 호출 활성화** (Line 577)
   - 주석 처리되었던 함수 호출 활성화

**핵심 개선점**:
- 중첩 switch 방지: 각 Insung 상태별로 함수 분리
- 40초 타이머: RunStartTime 필드로 운행 진입 시간 추적
- 로그 기반 골격: DB 업데이트/앱 취소는 Phase 2에서 구현
- 재적재 최적화: Kai 배차 상태일 때 NotChanged로 재적재하여 다시 확인

**커밋**: `a718918` - feat: Insung 주문 상태 관리 함수 구현 (Phase 1 - 골격 구현)

### 9. 인성 운행 상태 40초 타이머 및 기사 정보 자동 수집 구현 (2025-11-08)
**파일**:
- `InsungsAct_RcptRegPage.cs`
- `AutoAllocModel.cs`

**구현 내용**:

1. **AutoAllocModel에 DriverPhone 필드 추가** (AutoAllocModel.cs Line 54-58)
   ```csharp
   /// <summary>
   /// 인성 "운행" 상태에서 읽은 기사 전화번호 (40초 타이머용)
   /// </summary>
   public string DriverPhone { get; set; } = null;
   ```

2. **InsungOrderManage_운행Async 개선** (InsungsAct_RcptRegPage.cs Line 2286-2346)
   - **타이머 시작 시 기사 전화번호 수집**:
     - RunStartTime 설정
     - GetRowDriverPhNoAsync로 기사 전화번호 읽기
     - DriverPhone에 저장
   - **40초 경과 시**:
     - 수집한 기사 전화번호 로그 출력
     - TODO: Kai DB 업데이트 + 다른 앱 취소
   - **운행 취소 시 (접수/배차로 복귀)**:
     - RunStartTime = null
     - DriverPhone = null (초기화)

3. **GetRowDriverPhNoAsync 함수 추가** (InsungsAct_RcptRegPage.cs Line 3050-3054)
   - 캡처된 페이지에서 기사 전화번호 읽기
   - OfrStr_SeqCharAsync 사용

**핵심 로직**:
```csharp
// 운행 진입 시
if (item.RunStartTime == null)
{
    item.RunStartTime = DateTime.Now;

    // 기사 전화번호 수집
    var driverPhNoResult = await GetRowDriverPhNoAsync(dgInfo.BmpPage, rectDriverPhNo, dgInfo.bInvertRgb, ctrl);
    if (driverPhNoResult.Result == StdResult.Success)
        item.DriverPhone = driverPhNoResult.strResult;
}

// 40초 경과 시
if (elapsed.TotalSeconds >= 40)
{
    Debug.WriteLine($"기사 전화번호: {item.DriverPhone ?? "(없음)"}");
    // TODO: Kai DB 업데이트, 다른 앱 취소
}

// 운행 취소 시
item.RunStartTime = null;
item.DriverPhone = null;
```

**커밋**: `18b08ba` - feat: 인성 운행 상태 40초 타이머 및 기사 정보 자동 수집 구현

---

## 🔧 진행 중 작업

### 1. 상태 변경 확인 로직 추가 (2025-11-10 작업 예정)
**목적**: UpdateOrderStateOnlyAsync에서 상태 버튼 클릭 후 실제 변경 확인

**현재 문제**:
- 상태 버튼 클릭만 하고 실제로 UI에서 바뀌었는지 확인 안 함
- 로그상 성공이지만 실제로는 저장 안 됨

**해결 방안**:
1. 인성 앱 팝업에서 상태 표시 라벨 핸들 찾기
2. 상태 버튼 클릭 후 GetWindowText/GetWindowCaption으로 현재 상태 읽기
3. wantState와 일치하는지 검증
4. 불일치하면 재시도 또는 에러 반환

**구현 위치**:
- 파일: `InsungsAct_RcptRegPage.UI.cs`
- 함수: `UpdateOrderStateOnlyAsync` Line 1718-1740 (상태 버튼 클릭 부분)

**예상 로직**:
```csharp
// 2. 상태 버튼 클릭
await Std32Mouse_Post.MousePostAsync_ClickLeft_Center(hWndStateBtn);
await Task.Delay(CommonVars.c_nWaitNormal, ctrl.Token);

// 2-1. 상태 변경 확인 (추가)
string currentState = Std32Window.GetWindowCaption(wnd.상태라벨_hWnd);
if (currentState != wantState)
{
    Debug.WriteLine($"상태 변경 실패: 현재={currentState}, 목표={wantState}");
    await CloseEditPopupAsync(wnd, shouldSave: false, ctrl);

    if (attempt < repeatCount - 1)
        continue; // 재시도
    else
        return CommonResult_AutoAllocProcess.SuccessAndReEnqueue(); // 실패
}

Debug.WriteLine($"상태 변경 확인 완료: {wantState}");
```

### 2. RightSliding 재귀 로직 개선
**목적**: "123456789"처럼 많은 문자가 붙어있을 때 재귀 처리

**현재 문제**:
- RightSliding 2단계에서 나머지 영역 통째로 DB 검색
- 여러 문자 붙어있으면 실패 → "☒9" 부분 실패 결과

**해결 방안**: 가로/세로 비율 기준 (1.25배)
```csharp
if (width <= height * 1.25)
{
    // 단일 문자 가능성 → 전경/배경 방식 먼저 시도
    // 실패 시 → 재귀 RightSliding
}
else
{
    // 여러 문자 확실 → 바로 재귀 RightSliding
}
```

**수정 위치**:
- 파일: `Ofr_CharSet_Core.cs`
- 함수: `RecognizeCharSetAsync_RightSliding`
- Line: 584-655 (2단계 부분)

### 3. Region 5-3 - 기존 주문 처리
**목표**: 페이지별로 순회하며 리스트 전체 검사

**완료 상태**:
- ✅ 페이지별 검증 및 캡처 (NwInsung01.cs Line 437-459)
- ✅ GetValidRowCountAsync 함수 구현
- ✅ GetRowSeqnoAsync 함수 구현
- ✅ 마지막 페이지 startIndex 자동 계산
- ✅ 첫 페이지 첫 로우 자동 선택
- ✅ 로우별 주문번호 OFR (테스트 완료)

**남은 작업**:

**우선순위 1: listEtcGroup 순회 및 주문번호 매칭**
- [ ] listEtcGroup 역순 순회 구현
- [ ] 읽은 주문번호와 listEtcGroup의 Insung1 비교
- [ ] 찾으면 해당 항목의 StateFlag에 따라 처리
- **구현 위치**: NwInsung01.cs Line 481 for 루프 내부

**우선순위 2: StateFlag별 처리 구현**
- [x] CheckIsOrderAsync_InsungOrderManage 구현 (2025-11-07 완료)
- [ ] Command_ChaneTo취소AndDoDelete 구현
- [ ] CheckIsOrderAsync_AssumeKaiUpdated 구현
- [ ] 재적재 로직 구현

---

## 📊 상태 전환 매트릭스 설계

### 🎯 핵심 목표
**Insung 앱의 상태 변화를 감지하여 Kai DB와 다른 외부 앱들을 동기화**

---

### 📊 1. 상태 정의

#### Insung 앱 상태
| 상태 | 설명 | 최종 상태 |
|------|------|-----------|
| 접수 | 주문 접수됨 (기사 미배정) | ❌ |
| 배차 | 기사 배정됨 | ❌ |
| 운행 | 기사 운행 중 | ❌ |
| 완료 | 배송 완료 | ✅ |
| 취소 | 주문 취소됨 | ✅ |
| 대기 | 일시 대기 상태 | ❌ |
| 예약 | 예약 주문 | ❌ |

#### StateFlag (PostgService_Common_OrderState)
| 플래그 | 의미 | 처리 방향 |
|--------|------|-----------|
| `NotChanged` | Kai DB 변화 없음 | **Insung → Kai** (역방향) |
| `Existed_WithSeqno` | 이미 등록됨 | Kai → Insung |
| `Updated_Assume` | Kai DB 업데이트 추정 | Kai → Insung |
| `Updated_Status` | 상태만 변경됨 | Kai → Insung |
| `Updated_Etc` | 기타 필드 변경됨 | Kai → Insung |
| `CompletedExternal` | 외부에서 완료됨 | Kai → Insung (취소) |

---

### 🔄 2. 인성 앱 상태의 실제 의미

#### ⚠️ 중요: Insung 상태 ≠ Kai 상태

| Insung 상태 | 실제 의미 | 기사 확정? | Kai 상태 매핑 |
|-------------|----------|-----------|--------------|
| 접수 | 주문 등록됨, 기사 미배정 | ❌ | **접수** |
| 배차 | 기사가 "관심 있음" 표시 (확정 아님) | ❌ | **접수** |
| 운행 | 배달 수행 의사 표시 (40초 내 취소 가능) | ⏱️ | **접수** (40초 이내) |
| 운행 | 40초 경과 → 기사 확정 | ✅ | **배차** (40초 경과) |
| 완료 | 배송 완료 | ✅ | **완료** |
| 취소 | 주문 취소 | - | **취소** |

#### 핵심 규칙
```
Kai "접수" = Insung "접수" OR "배차" OR "운행(40초 이내)"
Kai "배차" = Insung "운행(40초 경과)"
Kai "완료" = Insung "완료"
Kai "취소" = Insung "취소"
```

---

### 🔄 3. 상태 전환 시나리오

#### A. Kai → Insung (현재 구현됨 ✅)
**함수**: `CheckIsOrderAsync_AssumeKaiUpdated`

| From (Kai) | To (Insung) | 액션 | useRepeat |
|------------|-------------|------|-----------|
| 취소 | 접수 | 팝업 열고 상태 전환 | true (10회) |
| 대기 | 접수 | 팝업 열고 상태 전환 | true (10회) |
| 취소 | 대기 | 팝업 열고 상태 전환 | false (1회) |
| 접수 | 대기 | 팝업 열고 상태 전환 | true (10회) |
| 배차 | 대기 | 팝업 열고 상태 전환 | true (10회) |
| 접수 | 취소 | 팝업 열고 상태 전환 | true (10회) |
| 배차 | 취소 | 팝업 열고 상태 전환 | true (10회) |
| 운행 | 취소 | 팝업 열고 상태 전환 | true (10회) |
| 예약 | 취소 | 팝업 열고 상태 전환 | false (1회) |
| 완료 | 취소 | 팝업 열고 상태 전환 | false (1회) |
| 대기 | 취소 | 팝업 열고 상태 전환 | false (1회) |
| 접수 | 접수 | 필드만 업데이트 | true (10회) |
| 배차 | 배차 | 필드만 업데이트 | true (10회) |
| 취소 | 취소 | 필드만 업데이트 | false (1회) |
| 대기 | 대기 | 필드만 업데이트 | false (1회) |

---

#### B. Insung → Kai (구현 필요 ⚠️)
**함수**: `CheckIsOrderAsync_KaiSameInsungIfChanged`

##### 시나리오 1: Insung "접수 → 배차" (기사 관심 표시)
**Kai 상태**: 접수 유지 (변화 없음)

| 단계 | 액션 | 함수/로직 |
|------|------|-----------|
| 1 | 상태 확인 | Kai="접수", Insung="배차" → 정상 (매핑 일치) |
| 2 | Kai DB | 업데이트 안 함 |
| 3 | 다른 앱 | 아무 동작 안 함 |
| 4 | 큐 관리 | `SuccessAndReEnqueue` (계속 모니터링) |

##### 시나리오 2: Insung "배차 → 운행" (배달 수행 의사)
**Kai 상태**: 접수 유지 (아직 40초 경과 전)

| 단계 | 액션 | 함수/로직 |
|------|------|-----------|
| 1 | 타이머 시작 | 운행 진입 시간 기록: `item.RunStartTime = DateTime.Now` |
| 2 | 기사 정보 수집 | `item.DriverPhone` 설정 |
| 3 | Kai DB | 업데이트 안 함 (아직 접수) |
| 4 | 다른 앱 | 아무 동작 안 함 |
| 5 | 큐 관리 | `SuccessAndReEnqueue` (40초 경과 체크 위해) |

##### 시나리오 3: Insung "운행" 40초 경과 (기사 확정!) ⚠️
**Kai 상태**: 접수 → 배차 (확정)

| 단계 | 액션 | 함수/로직 |
|------|------|-----------|
| 1 | 40초 체크 | `DateTime.Now - item.RunStartTime > 40초` |
| 2 | **다른 앱 상태 체크** | Insung2, 화물24시, 원콜의 현재 상태 확인 |
| 3 | **충돌 감지** | 다른 앱도 "운행" 상태? → 수동 선택 필요 |
| 4 | 충돌 없으면 | Kai DB 업데이트 "접수" → "배차" |
| 5 | 다른 앱 취소 | 접수/배차 상태인 앱들만 자동 취소 |
| 6 | 큐 관리 | `SuccessAndReEnqueue` (완료까지 모니터링) |

##### 시나리오 4: Insung "운행 → 접수/배차" (40초 내 취소)
**Kai 상태**: 접수 유지 (변화 없음)

| 단계 | 액션 | 함수/로직 |
|------|------|-----------|
| 1 | 타이머 취소 | `item.RunStartTime = null` |
| 2 | 기사 정보 초기화 | `item.DriverPhone = null` |
| 3 | Kai DB | 업데이트 안 함 (계속 접수) |
| 4 | 다른 앱 | 아무 동작 안 함 |
| 5 | 큐 관리 | `SuccessAndReEnqueue` (계속 모니터링) |

##### 시나리오 5: Insung "운행(확정) → 완료" (배송 완료)
**Kai 상태**: 배차 → 완료

| 단계 | 액션 | 함수/로직 |
|------|------|-----------|
| 1 | Kai DB 업데이트 | "배차" → "완료" |
| 2 | 다른 앱 | 없음 (이미 취소되었을 것) |
| 3 | 큐 관리 | `SuccessAndDestroy` (모니터링 종료) |

##### 시나리오 6: Insung "접수/배차/운행 → 취소" (주문 취소)
**Kai 상태**: 접수 → 취소 OR 배차 → 취소

| 단계 | 액션 | 함수/로직 |
|------|------|-----------|
| 1 | Kai DB 업데이트 | 현재 상태 → "취소" |
| 2 | 다른 앱 취소 | 모든 외부 앱에서 취소 처리 |
| 3 | 큐 관리 | `SuccessAndDestroy` (모니터링 종료) |

---

### 📊 4. 전체 흐름 요약

#### 정상 흐름 (배송 완료)
```
1. Kai DB: 접수 → Insung1 등록
2. Insung1: 접수 → (Kai: 접수 유지)
3. Insung1: 배차 → (Kai: 접수 유지)
4. Insung1: 운행 진입 → (타이머 시작, 기사 정보 수집, Kai: 접수 유지)
5. 40초 경과 → 다른 앱 상태 체크
   - 충돌 없음 → (Kai: 접수 → 배차, 다른 앱 자동 취소)
6. Insung1: 완료 → (Kai: 배차 → 완료, 모니터링 종료)
```

#### 40초 내 취소 흐름
```
1. Kai DB: 접수 → Insung1 등록
2. Insung1: 접수 → (Kai: 접수 유지)
3. Insung1: 배차 → (Kai: 접수 유지)
4. Insung1: 운행 진입 → (타이머 시작, 기사 정보 수집, Kai: 접수 유지)
5. 10초 후 Insung1: 배차로 복귀 → (타이머 리셋, 기사 정보 초기화, Kai: 접수 유지)
6. 다른 앱 계속 유효 (취소 안 됨)
```

#### 취소 흐름
```
1. Kai DB: 접수 → Insung1 등록
2. Insung1: 취소 → (Kai: 접수 → 취소, 다른 앱 취소, 모니터링 종료)
```

---

## 🏗️ 골격 구현 계획

### 🎯 목표: 상황별 분기만 명확히 + 골격만 구현

---

### 📐 핵심 분기 로직 (5가지만)

```csharp
string kaiState = item.NewOrder.OrderState;
string insungState = dgInfo.sStatus;

// ===== 분기 1: Kai 접수 + Insung 접수/배차 =====
if (kaiState == "접수" && (insungState == "접수" || insungState == "배차"))
{
    // 타이머 리셋 (있었다면)
    if (item.RunStartTime != null)
        item.RunStartTime = null;

    return SuccessAndReEnqueue();
}

// ===== 분기 2: Kai 접수 + Insung 운행 =====
if (kaiState == "접수" && insungState == "운행")
{
    // 2-1. 타이머 시작
    if (item.RunStartTime == null)
    {
        item.RunStartTime = DateTime.Now;
        return SuccessAndReEnqueue();
    }

    // 2-2. 타이머 체크
    TimeSpan elapsed = DateTime.Now - item.RunStartTime.Value;
    if (elapsed.TotalSeconds >= 40)
    {
        // 40초 경과! → Kai 배차로 업데이트 + 다른 앱 처리
        // TODO: 충돌 체크 (Phase 2에서 추가)
        await UpdateKaiStateAsync(item, "배차");
        await CancelOtherAppsAsync(item, ctrl);
        item.RunStartTime = null;
        return SuccessAndReEnqueue();
    }

    return SuccessAndReEnqueue();
}

// ===== 분기 3: Kai 배차 + Insung 완료 =====
if (kaiState == "배차" && insungState == "완료")
{
    await UpdateKaiStateAsync(item, "완료");
    return SuccessAndDestroy("배송 완료");
}

// ===== 분기 4: Insung 취소 =====
if (insungState == "취소")
{
    await UpdateKaiStateAsync(item, "취소");
    await CancelOtherAppsAsync(item, ctrl);
    return SuccessAndDestroy("주문 취소");
}

// ===== 분기 5: 미정의 (에러) =====
return FailureAndDiscard($"미정의: Kai={kaiState}, Insung={insungState}");
```

---

### 🏗️ 골격 함수 (3개만)

#### 1. CheckIsOrderAsync_KaiSameInsungIfChanged (메인)
```csharp
public async Task<CommonResult_AutoAllocProcess> CheckIsOrderAsync_KaiSameInsungIfChanged(
    AutoAllocModel item,
    CommonResult_AutoAllocDatagrid dgInfo,
    CancelTokenControl ctrl)
{
    // 위의 5가지 분기 로직 구현
    // TODO는 최소화
}
```

#### 2. UpdateKaiStateAsync (헬퍼)
```csharp
private async Task<bool> UpdateKaiStateAsync(AutoAllocModel item, string newState)
{
    StdResult_Int result = await CommonVars.s_SrGClient.SrResult_OnlyOrderState_UpdateRowAsync_Today(
        item.NewOrder,
        newState
    );

    if (result.nResult > 0)
    {
        Debug.WriteLine($"  → Kai DB 업데이트 성공: {item.NewOrder.OrderState} → {newState}");
        return true;
    }
    else
    {
        Debug.WriteLine($"  → Kai DB 업데이트 실패: {result.sErrNPos}");
        return false;
    }
}
```

#### 3. CancelOtherAppsAsync (스텁)
```csharp
private async Task CancelOtherAppsAsync(AutoAllocModel item, CancelTokenControl ctrl)
{
    Debug.WriteLine($"[CancelOtherAppsAsync] 다른 앱 취소 시작: KeyCode={item.KeyCode}");

    // TODO: Insung2 취소
    if (!string.IsNullOrEmpty(item.NewOrder.Insung2))
    {
        Debug.WriteLine($"  - Insung2 취소: {item.NewOrder.Insung2} [TODO]");
    }

    // TODO: 화물24시 취소
    if (!string.IsNullOrEmpty(item.NewOrder.Hwamul24))
    {
        Debug.WriteLine($"  - 화물24시 취소: {item.NewOrder.Hwamul24} [TODO]");
    }

    // TODO: 원콜 취소
    if (!string.IsNullOrEmpty(item.NewOrder.OneCall))
    {
        Debug.WriteLine($"  - 원콜 취소: {item.NewOrder.OneCall} [TODO]");
    }

    Debug.WriteLine($"[CancelOtherAppsAsync] 다른 앱 취소 완료 (스텁)");
}
```

---

### 📋 구현 순서 (단계별)

#### Phase 1: 골격 구현 ✅ (완료)
**목표**: 분기 로직만 동작하게

1. **InsungsAct_RcptRegPage.cs**에 함수 추가
   - `CheckIsOrderAsync_KaiSameInsungIfChanged` (5가지 분기만)
   - `UpdateKaiStateAsync` (헬퍼)
   - `CancelOtherAppsAsync` (스텁, TODO만)

2. **NwInsung01.cs** Line 577 주석 해제
   ```csharp
   resultAuto = await m_Context.RcptRegPageAct.CheckIsOrderAsync_KaiSameInsungIfChanged(
       foundItem, dgInfoNotChanged, ctrl);
   ```

3. **빌드 및 기본 테스트**
   - 컴파일 에러 없이 빌드
   - 로그 출력 확인 (분기 진입 확인)

---

#### Phase 2: 실제 동작 테스트 (다음 단계)
**목표**: 각 분기가 실제로 동작하는지 확인

1. 분기 1 테스트: Kai 접수 + Insung 접수/배차
   - 로그: "접수 유지, 모니터링 계속"

2. 분기 2 테스트: 40초 타이머
   - 로그: "운행 진입 - 타이머 시작"
   - 로그: "운행 중 - 경과 시간: X초"
   - 로그: "40초 경과! Kai DB 업데이트"

3. 분기 3/4/5 테스트

---

#### Phase 3: TODO 채워나가기 (시행착오)
**실제 환경에서 발견되는 문제들을 하나씩 해결**

1. **CancelOtherAppsAsync 구현**
   - Insung2 취소 로직
   - 화물24시 취소 로직
   - 원콜 취소 로직

2. **충돌 감지 추가** (분기 2에 추가)
   ```csharp
   if (elapsed.TotalSeconds >= 40)
   {
       // TODO: 다른 앱 상태 체크
       // TODO: 충돌 있으면 수동 선택
       // TODO: 충돌 없으면 자동 취소
   }
   ```

3. **예외 처리**
   - DB 업데이트 실패 시 재시도
   - 타임아웃 처리
   - 네트워크 오류 처리

---

#### Phase 4: 고급 기능 (나중에)
**충돌 처리, 수동 선택 등**

1. GetOtherAppStatesAsync 구현
2. ManualSelectionDialog WPF 대화상자
3. ShowManualSelectionDialogAsync 구현
4. CancelUnselectedAppsAsync 구현

---

## 📌 주요 상수 및 참고

### Datagrid 컬럼 (InsungsAct_RcptRegPage.cs Line 88-90)
- `c_nCol상태 = 1`
- `c_nCol주문번호 = 2`
- `c_nColForClick = 3`

### Datagrid 구조
- y=0: 헤더
- y=1: 빈 행 (Empty Row)
- y=2~: 데이터 행

### 대기 시간
- `c_nWaitShort`: 짧은 대기
- `c_nWaitNormal`: 보통 대기
- `c_nWaitLong = 250ms`: 긴 대기

### 재시도 횟수
- `c_nRepeatShort = 3`: 3회 재시도
- `c_nRepeatNormal = 10`: 10회 재시도

---

## 🔗 최근 커밋

- `18b08ba` - feat: 인성 운행 상태 40초 타이머 및 기사 정보 자동 수집 구현 (2025-11-08)
- `a718918` - feat: Insung 주문 상태 관리 함수 구현 (Phase 1 - 골격 구현) (2025-11-07)
- `45bf78c` - fix: SignalR 주문 업데이트 처리 로직 개선 (2025-11-06)
- `7fc974b` - refactor: OFR 함수 오버로드 패턴 적용 및 코드 간소화 (2025-11-04)
- `f78e473` - feat: ReEnqueue 함수 개선 및 Skip case 처리 추가
- `f99e928` - feat: Region 5-3 페이지별 검색 루프 구조 구현
- `40a2161` - feat: Region 5-1, 5-2 구현 (기존 주문 관리)

---
