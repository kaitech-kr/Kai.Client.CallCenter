# 작업 기록 통합 문서

**최종 업데이트**: 2025-11-23

---

## 📌 현재 작업 상태

### 🔨 진행 중 작업 (2025-11-23)

#### ONECALL Datagrid 초기화 - 마지막 경계선 검출 문제

**파일**: `OnecallAct_RcptRegPage.cs`

**현재 문제**:
- 마지막 컬럼의 오른쪽 경계가 캡처폭에 너무 가까우면 마지막 영역이 검출 안 됨
- 22개 검출 → 마지막 제거 → 21개 (정상)
- 21개 검출 → 마지막 제거 → 20개 (부족)

**테스트 결과**:
```
listLW 검출: 21개, 캡처폭=1916
마지막[20] Left=1838, Width=70, Right=1908
→ 캡처폭 - Right = 8px (너무 좁아서 별도 영역 검출 안 됨)
```

**마지막 제거 이유**:
끝 영역은 잘려서 불확실한 OFR이 되므로 신뢰성 없는 자료로 무조건 버림

**다음 작업**:
1. 마지막 항목 제거 조건 수정:
   ```csharp
   // 기존
   if (listLW.Count >= 1)
       listLW.RemoveAt(listLW.Count - 1);

   // 수정
   if (listLW.Count > m_ReceiptDgHeaderInfos.Length)
       listLW.RemoveAt(listLW.Count - 1);
   ```
2. 디버그 메시지박스 제거 (라인 206-213)
3. 테스트 및 검증

**참고 - 컬럼 너비 최소값**: 50px (순번, 톤수)

**참고 - 컬럼 너비 합계**: 1755px (캡처폭 1916px, 여유 161px)

---

### 🔨 이전 작업 (2025-11-20)

#### Cargo24 코드 품질 개선 및 MainWnd 초기화 안정성 향상

**파일**:
- `Cargo24sAct_RcptRegPage.cs`
- `Cargo24sAct_MainWnd.cs`

**구현 내용**:

**1. 상수화 - Magic Numbers를 클래스 레벨 상수로**
```csharp
#region Constants
private const int COLUMN_WIDTH_TOLERANCE = 1;  // 인성과 동일

// 헤더/캡처 관련
private const int HEADER_HEIGHT = 30;
private const int TARGET_ROW = 2;
private const int HEADER_GAB = 7;
private const int OFR_HEIGHT = 20;
private const int MIN_COLUMN_WIDTH = 30;
private const int BRIGHTNESS_OFFSET = 2;

// 재시도/대기 관련
private const int MAX_RETRY = 3;
private const int DELAY_AFTER_INIT = 1000;
private const int DELAY_AFTER_DRAG = 150;
private const int DELAY_RETRY = 500;
private const int DELAY_DIALOG_CHECK = 50;

// Step 2 특수 컬럼 처리
private const int SPECIAL_COL_START = 24;
private const int SPECIAL_COL_END = 26;
private const int SPECIAL_COL_OFFSET = 30;
#endregion
```

**2. 로그 prefix 통일**
- `[Cargo24/InitDG오더]`, `[Cargo24/SetDG오더]` 형식으로 통일
- 불필요한 상세 로그 제거 (컬럼별 OFR 결과, 너비 검증 등)

**3. Dispose 패턴 일관성**
- 모든 `bmpHeader.Dispose()`를 `bmpHeader?.Dispose()`로 통일

**4. InitDG오더Async에 finally 추가**
```csharp
Draw.Bitmap? bmpHeader = null;
try
{
    // ... 기존 로직
}
catch (Exception ex)
{
    // 에러 처리
}
finally
{
    bmpHeader?.Dispose();  // 안전한 리소스 정리
}
```

**5. MainWnd 초기화 안정성 향상**

문제: 차일드 윈도우/메뉴 찾기가 루프 없이 한 번만 시도
- 윈도우 최대화 후 레이아웃 안정화 전에 찾기 시도 → 실패

해결: 5초 재시도 루프 추가 (50회 × 100ms)
```csharp
// 5. 차일드 윈도우 정보 수집 및 메뉴 찾기 (5초 대기)
for (int i = 0; i < 50; i++)
{
    m_Main.FirstLayer_ChildWnds = Std32Window.GetChildWindows_FirstLayer(m_Main.TopWnd_hWnd);

    if (m_Main.FirstLayer_ChildWnds.Count > 0)
    {
        m_Main.WndInfo_MainMenu = m_Main.FirstLayer_ChildWnds.FirstOrDefault(...);
        m_Main.WndInfo_BarMenu = m_Main.FirstLayer_ChildWnds.FirstOrDefault(...);
        m_Main.WndInfo_MdiClient = m_Main.FirstLayer_ChildWnds.FirstOrDefault(...);

        // 모두 찾으면 탈출
        if (모두 != null) break;
    }

    await Task.Delay(c_nWaitNormal);
}
```

**미완료 (옵션)**:
- 헬퍼 메서드 추출 (`CaptureAndDetectColumns`) - 각 호출 지점마다 에러 처리가 달라서 복잡성 높음

**커밋**: `d472584` - refactor: Cargo24 코드 품질 개선 및 MainWnd 초기화 안정성 향상

#### Onecall 접수등록Page 초기화 구현

**파일**:
- `NwOnecall.cs` (신규)
- `NwOnecalls/OnecallContext.cs` (신규)
- `NwOnecalls/OnecallInfo_File.cs` (신규)
- `NwOnecalls/OnecallInfo_Mem.cs` (신규)
- `NwOnecalls/OnecallAct_App.cs` (신규)
- `NwOnecalls/OnecallAct_MainWnd.cs` (신규)
- `NwOnecalls/OnecallAct_RcptRegPage.cs` (신규)

**구현 내용**:

**1. Context 패턴 적용**
- `OnecallContext`: FileInfo, MemInfo, AppAct, MainWndAct, RcptRegPageAct 관리
- Insung/Cargo24와 동일한 구조

**2. RcptRegPage InitializeAsync**
```csharp
// 1. 접수등록Page 윈도우 찾기
// 2. 자식윈도우 찾기 (3개)
// 3. 접수영역 찾기 (rcRel 기반)
// 4. 검색영역 찾기 (wndName 기반)
// 5. DG오더 찾기 (rcRel 기반)
// 6. 확장버튼 찾기 (상대좌표 기반)
// 7. 확장버튼 클릭 및 DG오더 확장 대기
```

**3. OnecallInfo_File 설정값**
- `Main_TopWnd_sWndNameReduct = "(주)원콜"` (백업에서 찾음)
- `Main_MainMenu_rcRel = new Rectangle(8, 31, 1920, 45)`
- `접수등록Page_DG오더_nExpandedHeight = 874`

**테스트 결과**:
```
[ONECALL] 접수등록Page 자식윈도 찾음: 3개
[ONECALL] 접수영역 찾음: 160936
[ONECALL] 검색영역 찾음: 1B09E0
[ONECALL] DG오더 찾음: 140A7A
[ONECALL] 확장버튼 찾음: XXXXXX
[ONECALL] DG오더 확장완료: 874
[ONECALL] RcptRegPage InitializeAsync 성공
```

**다음 작업**:
- DataGrid 컬럼 초기화 (SetDG오더SmallRectsAsync, SetDG오더LargeRectsAsync)
- OFR 기반 컬럼 헤더 인식 필요

**커밋**: `dbe76db` - feat: Onecall 접수등록Page 초기화 구현

---

### 🔨 이전 작업 (2025-11-19)

#### Cargo24 Datagrid 헤더 캡처 및 컬럼 경계 검출 구현

**파일**:
- `Cargo24sAct_RcptRegPage.cs` (Line 218-345)

**구현 내용**:

**Step 4-1: Datagrid 헤더 영역만 캡처**
- 전체 Datagrid(1916x637) 대신 **헤더만 캡처(1916x32)**
- **Datagrid 핸들 + Datagrid 기준 상대좌표** 사용
  ```csharp
  Draw.Rectangle rcHeaderInDG = new Draw.Rectangle(0, 0, DG오더_AbsRect.Width, headerHeight);
  bmpDG = OfrService.CaptureScreenRect_InWndHandle(DG오더_hWnd, rcHeaderInDG);
  ```

**Step 4-2: 헤더 최소 밝기 검출**
- `GetMinBrightnessAtRow_FromColorBitmapFast` 사용
- 경계선이 어두우므로 `minBrightness -= 2` (더 정확한 검출)

**Step 4-3: Bool 배열 생성 및 컬럼 경계 검출**
- `GetBoolArray_FromColorBitmapRowFast` → Bool 배열 생성
- `GetLeftWidthList_FromBool1Array` → 컬럼 경계 리스트 추출
- 첫/마지막 항목 제거 (테두리 + 오른쪽 끝)

**디버깅**:
- `TransparantWnd`로 캡처 영역 시각화 (빨간 테두리)
- DG 핸들 기준 오버레이 + DG 기준 상대좌표 사용

**문제 및 해결**:
1. ❌ **MainWnd 핸들로 캡처** → ✅ Datagrid 핸들로 수정
2. ❌ **절대좌표/상대좌표 혼동** → ✅ 함수 분석 후 올바른 좌표 사용
3. ❌ **전체 영역 캡처(637px)** → ✅ 헤더만 캡처(32px)

**Using 추가**:
- `System.Linq` (List, Math.Min)
- `System.Windows.Media` (Colors)

**커밋**: `f66f223` - feat: Cargo24 Datagrid 헤더 캡처 및 컬럼 경계 검출 구현

---

### 🔨 이전 작업 (2025-11-11)

#### 완료 상태 팝업 처리 및 저장 버튼 위치 문제 해결

**파일**:
- `InsungsAct_RcptRegPage.UI.cs` (Line 1700-1850)
- `InsungsInfo_Mem.cs` (Line 355-372)
- `InsungsInfo_File.cs` (Line 311-314)

**문제 상황**:
1. 완료 상태 주문을 취소로 변경 시도
2. 상태 버튼 클릭은 성공 (화면에서 '취소'로 표시됨)
3. 저장 버튼 클릭도 성공 로그가 나옴
4. **하지만 실제 DB에는 저장되지 않음**

**원인 분석**:
- 인성 앱 팝업에는 3가지 버튼 레이아웃 존재:
  1. **신규버튼그룹**: 신규 접수용
  2. **수정버튼그룹**: 일반 주문 수정용 (RcptWnd_Edit)
  3. **완료상태버튼그룹**: 완료 상태일 때만 나타나는 레이아웃 ⭐ **새로 발견!**
- 완료 상태일 때는 버튼 위치가 다른데, RcptWnd_Edit의 좌표로 클릭
- 엉뚱한 위치를 클릭하여 저장 실패

**해결 방법**:

1. **RcptWnd_Completed 클래스 생성** (InsungsInfo_Mem.cs:355-372)
   ```csharp
   public class RcptWnd_Completed
   {
       public IntPtr TopWnd_hWnd;
       public IntPtr Btn_hWnd주문취소;
       public IntPtr Btn_hWnd저장;
       public IntPtr Btn_hWnd닫기;

       public RcptWnd_Completed(IntPtr hWnd, InsungsInfo_File fInfo)
       {
           TopWnd_hWnd = hWnd;
           Btn_hWnd주문취소 = Std32Window.GetWndHandle_FromRelDrawPt(hWnd, fInfo.접수등록Wnd_완료상태_ptChkRel주문취소);
           Btn_hWnd저장 = Std32Window.GetWndHandle_FromRelDrawPt(hWnd, fInfo.접수등록Wnd_완료상태_ptChkRel저장);
           Btn_hWnd닫기 = Std32Window.GetWndHandle_FromRelDrawPt(hWnd, fInfo.접수등록Wnd_완료상태_ptChkRel닫기);
       }
   }
   ```

2. **버튼 좌표 설정** (InsungsInfo_File.cs:311-314)
   ```csharp
   // 완료 상태 팝업 버튼 위치
   public Draw.Point 접수등록Wnd_완료상태_ptChkRel닫기 { get; set; } = new Draw.Point(889, 679);
   public Draw.Point 접수등록Wnd_완료상태_ptChkRel주문취소 { get; set; } = new Draw.Point(889, 408);
   public Draw.Point 접수등록Wnd_완료상태_ptChkRel저장 { get; set; } = new Draw.Point(889, 476);
   ```

3. **UpdateOrderStateOnlyAsync 함수 수정** (InsungsAct_RcptRegPage.UI.cs:1742-1844)
   ```csharp
   // 현재 인성 상태 확인
   bool isCompletedState = dgInfo.sStatus?.StartsWith("완료") == true;

   // 상태 버튼 핸들 얻기
   if (isCompletedState)
   {
       var wndCompleted = new InsungsInfo_Mem.RcptWnd_Completed(wnd.TopWnd_hWnd, m_FileInfo);
       hWndStateBtn = wndCompleted.Btn_hWnd주문취소;
   }
   else
   {
       hWndStateBtn = wantState switch {
           "접수" => wnd.Btn_hWnd접수상태,
           "완료" => wnd.Btn_hWnd처리완료,
           // ...
       };
   }

   // 저장 버튼 클릭
   if (isCompletedState)
   {
       var wndCompleted = new InsungsInfo_Mem.RcptWnd_Completed(wnd.TopWnd_hWnd, m_FileInfo);
       closed = await ClickNWaitWindowChangedAsync_OrFind확인창(wndCompleted.Btn_hWnd저장, wnd.TopWnd_hWnd, ctrl);
   }
   else
   {
       closed = await CloseEditPopupAsync(wnd, shouldSave: true, ctrl);
   }
   ```

**테스트 결과**:
- ✅ 완료 상태 감지: `dgInfo.sStatus?.StartsWith("완료")`
- ✅ RcptWnd_Completed로 버튼 핸들 획득
- ✅ MessageBox로 버튼 위치 확인 (마우스 커서가 정확히 버튼 위에 위치)
- ✅ 저장 버튼 클릭 성공
- ✅ DB에 상태 변경 정상 반영

**향후 개선 계획**:

현재 구조:
```
if (isCompletedState)
    상태 버튼 핸들 = RcptWnd_Completed
else
    상태 버튼 핸들 = RcptWnd_Edit

...

if (isCompletedState)
    저장 = RcptWnd_Completed
else
    저장 = CloseEditPopupAsync
```

문제점:
- isCompletedState 체크가 2군데 분산
- 완료 상태: 상태 변경만 가능
- 일반 상태: 상태 변경 + 기사정보/차량정보 등 변경 가능
- 현재는 상태 변경만 지원

**제안**: UpdateOrderStateOnlyAsync → UpdateOrderAsync로 확장
```csharp
UpdateOrderAsync(
    wantState,      // null이면 상태 변경 안함
    driverPhone,    // null이면 기사정보 변경 안함
    carType         // null이면 차량정보 변경 안함
)
```

**비교 로직 조사 결과**:

✅ **비교 후 업데이트하는 부분** (정상):
1. Update의뢰자영역Async (Line 1914-1952)
   - 예: `if (target전화1 != current전화1)` 체크 후 업데이트
2. Update우측상단영역Async (Line 2257-2375)
   - 예: `if ((order.OrderRemarks ?? "") != current적요)` 체크 후 업데이트

⚠️ **덮어쓰기 발견** (개선 필요):
- Update의뢰자영역Async (Line 1896-1911)
  ```csharp
  if (did고객검색)
  {
      // 고객 검색한 경우: 관련 필드 무조건 Kai DB 데이터로 덮어쓰기
      // ❌ 비교 없이 무조건 덮어쓰기
      await WriteAndVerifyEditBoxAsync(wnd.의뢰자_hWnd전화1, order.CallTelNo ?? "", ...);
      await WriteAndVerifyEditBoxAsync(wnd.의뢰자_hWnd전화2, order.CallTelNo2 ?? "", ...);
  }
  ```

**다음 작업**:
- [ ] Update의뢰자영역Async 덮어쓰기 부분 개선 (비교 로직 추가)
- [ ] UpdateOrderAsync로 확장 (상태 + 기사정보 + 차량정보 선택적 업데이트)
- [ ] 완료 상태와 일반 상태 처리 구조 개선 검토

---

## ✅ 완료된 작업

### 1. 상태 변경 확인 로직 추가 (2025-11-14)
**파일**: `InsungsAct_RcptRegPage.UI.cs`

**구현 내용**:
- UpdateOrderStateOnlyAsync에서 상태 버튼 클릭 후 실제 UI 상태 변경 확인
- 인성 앱 팝업에서 상태 표시 라벨 핸들 획득
- GetWindowText/GetWindowCaption으로 현재 상태 읽기
- wantState와 일치하는지 검증, 불일치 시 재시도

**핵심 로직**:
- 상태 버튼 클릭 후 대기
- 상태 라벨 읽어서 검증
- 불일치하면 팝업 닫고 재시도 또는 에러 반환

### 2. RightSliding 재귀 로직 개선 (2025-11-14)
**파일**: `Ofr_CharSet_Core.cs`

**구현 내용**:
- "123456789"처럼 많은 문자가 붙어있을 때 재귀 처리 개선
- 가로/세로 비율 기준 (1.25배)으로 단일/다중 문자 판단
- width <= height * 1.25: 단일 문자 가능성 → 전경/배경 방식 먼저 시도
- width > height * 1.25: 여러 문자 확실 → 바로 재귀 RightSliding

**핵심 개선점**:
- RightSliding 2단계에서 나머지 영역 통째로 DB 검색 실패 해결
- "☒9" 같은 경우 개선

### 3. listEtcGroup 순회 및 주문번호 매칭 (2025-11-14)
**파일**: `NwInsung01.cs`

**구현 내용**:
- Region 5-3: 페이지별로 순회하며 리스트 전체 검사
- listEtcGroup 역순 순회 구현
- 읽은 주문번호와 listEtcGroup의 Insung1 비교
- 찾으면 해당 항목의 StateFlag에 따라 처리

**핵심 로직**:
- OFR로 읽은 주문번호를 listEtcGroup에서 검색
- 매칭되면 StateFlag별 분기 처리
- CheckIsOrderAsync_InsungOrderManage 호출

### 4. UpdateOrderStateOnlyAsync 함수 구현 (2025-11-10 ~ 2025-11-11)
**파일**: `InsungsAct_RcptRegPage.UI.cs`, `InsungsInfo_Mem.cs`, `InsungsInfo_File.cs`

**배경**:
- 기존 UpdateOrderInPopupAsync는 필드 업데이트 → 상태 버튼 클릭 순서
- 요금 영역 업데이트 실패 시 early return → 상태 버튼까지 도달 못함
- 예: "완료→취소" 전환 시 요금 입력 실패 → 상태 변경 안 됨

**구현 내용** (Line 1700-1850):
- 팝업 열기 → 상태 버튼 클릭 → 저장 후 닫기
- 필드 업데이트 없이 상태만 변경
- 취소 상태면 SuccessAndDestroy, 그 외는 SuccessAndReEnqueue

**완료 상태 처리 추가** (2025-11-11):
- RcptWnd_Completed 클래스 생성
- 완료 상태일 때 별도 버튼 위치 사용
- 상태 버튼 및 저장 버튼 클릭 로직 분기 처리

### 5. 접수등록 - 요금 및 오더메모 입력 (2025-10-29)
**파일**: `InsungsAct_RcptRegPage.cs`

**구현 내용**:
- 요금 입력 (기본요금, 추가금액, 할인금액, 탁송료)
  - 보안상 키보드 시뮬레이션만 사용 (SetWindowText 불가)
  - `ResgistAndVerify요금Async` 함수로 입력 및 검증
- 오더메모 입력 (형식: `{KeyCode}/{OrderMemo}`)
  - `WriteAndVerifyEditBoxAsync` 사용

**핵심 함수**:
- `ResgistAndVerify요금Async` (Line 3739-3765): 요금 필드 입력/검증, 3회 재시도
- `WriteAndVerifyEditBoxAsync` (Line 3011-3071): EditBox 입력/검증

### 6. 접수등록 - 첫 로우 선택 검증 (2025-10-30)
**파일**: `InsungsAct_RcptRegPage.cs`

**구현 내용**:
- 첫 로우 선택 검증 (중심 라인 평균 밝기 방식)
  - 선택 시 반전되어 어두워짐 → `평균 밝기 < 배경 밝기 - 10`
- 첫 로우 클릭 함수 개선 (클릭 후 검증 및 재시도)

**핵심 함수**:
- `VerifyFirstRowSelectedAsync` (Line 2541-2603): 중심 라인 평균 밝기로 선택 검증
- `ClickFirstRowAsync` (Line 2482-2539): 클릭 후 검증, 실패 시 재시도

### 7. Datagrid 배경 밝기 측정 및 Region 5-1, 5-3 개선 (2025-11-02)
**파일**:
- `InsungsAct_RcptRegPage.cs`
- `NwInsung01.cs`

**구현 내용**:
1. **배경 밝기 측정 위치 수정**
   - Empty Row의 샘플 포인트를 (3,3)에서 (8,8)로 변경
   - 측정값이 211에서 255로 개선되어 정확도 향상
   - `InsungsAct_RcptRegPage.cs` Line 832

2. **Region 5-1: 총계 읽기 로직 개선**
   - 한 번만 시도하던 로직을 백업 코드처럼 반복 구조로 변경
   - 조회버튼 클릭과 총계 읽기를 `c_nRepeatNormal`회 반복
   - 실패 시 `c_nWaitNormal` 대기 후 재시도
   - `NwInsung01.cs` Line 376-400

3. **Region 5-3: 유효 로우 체크 로직 완성**
   - 페이지별 유효 로우 갯수 측정 구현
   - 밝기 측정 위치: `rects[0, y].Right, rects[0, y].Top + 6`
   - 임계값: `배경 밝기 - 1`
   - 밝기가 임계값 미만이면 유효 로우로 카운트
   - `NwInsung01.cs` Line 465-479

### 8. 페이지 검증 및 자동 조정 (2025-11-03)
**파일**:
- `InsungsAct_RcptRegPage.cs`
- `InsungsInfo_File.cs`
- `OfrWork_Commons.cs`
- `NwInsung01.cs`

**구현 내용**:
1. **GetExpectedFirstRowNum 함수** (InsungsAct_RcptRegPage.cs Line 2805-2828)
   - 페이지별 예상 첫 로우 번호 계산 (0-based 인덱스)
   - 마지막 페이지 특수 처리 (나머지 행 계산)
   - public static으로 선언 → 인성1, 인성2 공통 사용

2. **ReadFirstRowNumAsync 함수** (InsungsAct_RcptRegPage.cs Line 2830-2865)
   - OFR로 번호 컬럼(x=0) 실제 첫 번호 읽기
   - bEdit 매개변수로 대화상자 제어 (기본값: false)
   - y=2부터 순차적으로 OFR 시도

3. **VerifyAndAdjustPageAsync 함수** (InsungsAct_RcptRegPage.cs Line 2867-2943)
   - 페이지 검증 및 자동 조정 (재시도 3회)
   - 최소 클릭 최적화: rowClicks > 14이면 역방향 스크롤
   - 페이지/로우 스크롤 구분
   - public 메서드 → 인성1, 인성2 공통 사용

4. **OfrStr_SeqCharAsync 개선** (OfrWork_Commons.cs Line 282, 339)
   - bEdit 매개변수 추가 (기본값: true)
   - `if (bEdit && s_bDebugMode)` 조건 추가

5. **상수 변경** (InsungsInfo_File.cs Line 129)
   - `접수등록Page_DG오더_dataRowCount`를 const로 변경

### 9. 페이지 캡처 및 주문번호 OFR 구현 (2025-11-03)
**파일**:
- `InsungsAct_RcptRegPage.cs`
- `NwInsung01.cs`

**구현 내용**:
1. **GetValidRowCountAsync 함수** (InsungsAct_RcptRegPage.cs Line 2952-2981)
   - 캡처된 페이지 이미지에서 유효 로우 갯수 측정
   - 밝기 측정으로 실제 데이터 유무 확인
   - 임계값: 배경 밝기 - 1
   - StdResult_Int 반환 (에러 처리 포함)

2. **GetRowSeqnoAsync 함수** (InsungsAct_RcptRegPage.cs Line 2983-3033)
   - 캡처된 페이지 이미지에서 특정 로우의 주문번호 읽기
   - GetBitmapInBitmapFast로 영역 crop
   - bInvertRgb 매개변수로 선택된 행 RGB 반전 처리
   - OfrStr_SeqCharAsync로 주문번호 인식
   - StdResult_String 반환

3. **페이지 캡처 및 처리** (NwInsung01.cs Line 447-514)
   - 페이지별 데이터그리드 전체 캡처 (재시도 3회)
   - try-finally로 Bitmap 안전 해제
   - 유효 로우 갯수 얻기
   - 마지막 페이지 startIndex 자동 계산
   - 첫 페이지 첫 로우 자동 선택
   - 로우별 주문번호 OFR 및 Debug 출력

**주요 개선점**:
- 페이지당 1회 캡처로 성능 최적화 (셀마다 캡처 X)
- 마지막 페이지 빈 로우 자동 건너뜀
- 선택된 행 RGB 반전 자동 처리
- try-finally로 메모리 누수 방지

### 10. OFR 함수 오버로드 패턴 적용 및 코드 간소화 (2025-11-04)
**파일**:
- `OfrWork_Commons.cs`
- `InsungsAct_RcptRegPage.cs`
- `OfrService.cs` (Kai.Common.NetDll_WpfCtrl)

**구현 내용**:

1. **OfrStr_SeqCharAsync 오버로드 추가** (OfrWork_Commons.cs Line 390-415)
   - 파라미터: `(Draw.Bitmap bmpPage, Draw.Rectangle rect, bool bInvertRgb, bool bEdit = true)`
   - crop + RGB 반전 처리 후 기존 오버로드 호출
   - 중복 코드 제거로 코드 간소화

2. **OfrStr_ComplexCharSetAsync 오버로드 구조 생성** (OfrWork_Commons.cs)
   - **기본 오버로드** (Line 420-432): `(Draw.Bitmap bmpSource, bool bInvertRgb, bool bEdit = true)`
     - RGB 반전 처리 후 원본 함수 호출
     - TODO: 구현 필요 (원본 함수와 연동)
   - **OfrStr_ComplexCharSetAsync2** (Line 442-468): `(Draw.Bitmap bmpPage, Draw.Rectangle rect, bool bInvertRgb, bool bEdit = true)`
     - crop + RGB 반전 후 기본 오버로드 호출
     - OfrStr_SeqCharAsync와 동일한 패턴
   - **원본 함수** (Line 481~): `(Draw.Bitmap bmpOrg, Draw.Rectangle rcSpare, bool bSaveToTbText, bool bEdit, bool bWrite, bool bMsgBox)`
     - 기존 Stage 1-4 OFR 로직 유지

3. **InvertBitmap을 OfrService로 이동** (OfrService.cs Line 1135-1175)
   - 이유: InsungsAct_RcptRegPage → OfrWork_Commons 접근 불가
   - RGB 반전 로직: `dstBytes[i] = (byte)(255 - srcBytes[i])`
   - 재사용성 개선: 공통 유틸리티 레이어로 이동

4. **함수 간소화** (InsungsAct_RcptRegPage.cs)
   - **GetRowSeqnoAsync** (Line 2991-2995): 40+ lines → 3 lines
   - **GetRowStatusAsync** (Line 2956-2960): 40+ lines → 3 lines

**핵심 개선점**:
- 중복 코드 제거: crop + RGB 반전 로직을 오버로드로 통합
- 함수 간소화: 40+ lines → 3 lines
- 재사용성 개선: InvertBitmap을 공통 레이어로 이동
- 일관된 패턴: OfrStr_SeqCharAsync와 동일한 오버로드 구조

**커밋**: `7fc974b` - refactor: OFR 함수 오버로드 패턴 적용 및 코드 간소화

### 11. SignalR 주문 업데이트 처리 로직 개선 (2025-11-06)
**파일**:
- `ExternalAppController.cs`
- `QueueController.cs`
- `NwInsung01.cs`
- `InsungsAct_RcptRegPage.cs`

**구현 내용**:

1. **StateFlag 비트 연산 처리** (NwInsung01.cs Line 574-612)
   - 문제: switch 문으로는 비트 플래그(Updated_Status, Updated_Etc) 처리 불가
   - 해결: if-else chain으로 변경 + 비트 AND 연산자 사용

2. **상태 문자열 파싱** (NwInsung01.cs Line 567)
   - 문제: 인성 앱 상태가 "접수[1]", "접수[2]" 형식인데 switch는 "접수"만 체크
   - 해결: Substring(0, 2)로 앞 2글자만 추출

3. **큐 효율성 개선** (ExternalAppController.cs Line 185-218, 380-386)
   - 문제: SignalR 업데이트 시 4개 큐 모두 검색
   - 해결: GetTargetQueues() 함수로 차량 타입별 관련 큐만 검색

4. **재적재 로직 수정** (NwInsung01.cs Line 607-610)
   - 문제: 업데이트 성공 후 기존 StateFlag로 재적재 → 무한 루프 가능성
   - 해결: NotChanged 플래그로 재적재하여 계속 모니터링

5. **취소 상태 비적재 처리** (InsungsAct_RcptRegPage.cs Line 3978-3990, 3734-3736)
   - 문제: 취소 상태 전환 후에도 계속 큐에서 모니터링됨
   - 해결: wantState == "취소" 체크하여 SuccessAndComplete 반환

**핵심 개선점**:
- StateFlag 비트 연산으로 모든 업데이트 플래그 처리 가능
- 상태 문자열 파싱으로 인성 앱 형식 대응
- 큐 검색 최적화로 성능 향상 (4개 → 2개)
- NotChanged 플래그로 무한 루프 방지
- 취소 상태 자동 비적재로 불필요한 모니터링 제거

**커밋**: `45bf78c` - fix: SignalR 주문 업데이트 처리 로직 개선

### 12. Insung 주문 상태 관리 함수 구현 (2025-11-07)
**파일**:
- `InsungsAct_RcptRegPage.cs`
- `NwInsung01.cs`
- `AutoAllocModel.cs`

**구현 내용**:

1. **CheckIsOrderAsync_InsungOrderManage 메인 함수** (InsungsAct_RcptRegPage.cs Line 2216)
   - Insung 앱 상태 변화 모니터링 (NotChanged 상황 처리)
   - Insung 상태를 primary switch로 분기
   - 각 Insung 상태별 handler 함수 호출 (중첩 switch 방지)
   - 로그 기반 골격 구현 (DB 업데이트/앱 취소는 TODO)

2. **Insung 상태별 Handler 함수들** (InsungsAct_RcptRegPage.cs)
   - **InsungOrderManage_접수Or배차Async** (Line 2247): 접수/배차 상태 통합 처리
   - **InsungOrderManage_운행Async** (Line 2286): 운행 상태 + 40초 타이머
   - **InsungOrderManage_완료Async** (Line 2348): 완료 상태 처리
   - **InsungOrderManage_취소Async** (Line 2393): 취소 상태 처리

3. **AutoAllocModel에 RunStartTime 추가** (AutoAllocModel.cs Line 48-52)
   - 인성 "운행" 상태 진입 시간 추적 (40초 타이머용)

4. **NwInsung01.cs 호출 활성화** (Line 577)
   - 주석 처리되었던 함수 호출 활성화

**핵심 개선점**:
- 중첩 switch 방지: 각 Insung 상태별로 함수 분리
- 40초 타이머: RunStartTime 필드로 운행 진입 시간 추적
- 로그 기반 골격: DB 업데이트/앱 취소는 Phase 2에서 구현
- 재적재 최적화: Kai 배차 상태일 때 NotChanged로 재적재하여 다시 확인

**커밋**: `a718918` - feat: Insung 주문 상태 관리 함수 구현 (Phase 1 - 골격 구현)

### 13. 인성 운행 상태 40초 타이머 및 기사 정보 자동 수집 구현 (2025-11-08)
**파일**:
- `InsungsAct_RcptRegPage.cs`
- `AutoAllocModel.cs`

**구현 내용**:

1. **AutoAllocModel에 DriverPhone 필드 추가** (AutoAllocModel.cs Line 54-58)
   ```csharp
   /// <summary>
   /// 인성 "운행" 상태에서 읽은 기사 전화번호 (40초 타이머용)
   /// </summary>
   public string DriverPhone { get; set; } = null;
   ```

2. **InsungOrderManage_운행Async 개선** (InsungsAct_RcptRegPage.cs Line 2286-2346)
   - **타이머 시작 시 기사 전화번호 수집**:
     - RunStartTime 설정
     - GetRowDriverPhNoAsync로 기사 전화번호 읽기
     - DriverPhone에 저장
   - **40초 경과 시**:
     - 수집한 기사 전화번호 로그 출력
     - TODO: Kai DB 업데이트 + 다른 앱 취소
   - **운행 취소 시 (접수/배차로 복귀)**:
     - RunStartTime = null
     - DriverPhone = null (초기화)

3. **GetRowDriverPhNoAsync 함수 추가** (InsungsAct_RcptRegPage.cs Line 3050-3054)
   - 캡처된 페이지에서 기사 전화번호 읽기
   - OfrStr_SeqCharAsync 사용

**핵심 로직**:
```csharp
// 운행 진입 시
if (item.RunStartTime == null)
{
    item.RunStartTime = DateTime.Now;

    // 기사 전화번호 수집
    var driverPhNoResult = await GetRowDriverPhNoAsync(dgInfo.BmpPage, rectDriverPhNo, dgInfo.bInvertRgb, ctrl);
    if (driverPhNoResult.Result == StdResult.Success)
        item.DriverPhone = driverPhNoResult.strResult;
}

// 40초 경과 시
if (elapsed.TotalSeconds >= 40)
{
    Debug.WriteLine($"기사 전화번호: {item.DriverPhone ?? "(없음)"}");
    // TODO: Kai DB 업데이트, 다른 앱 취소
}

// 운행 취소 시
item.RunStartTime = null;
item.DriverPhone = null;
```

**커밋**: `18b08ba` - feat: 인성 운행 상태 40초 타이머 및 기사 정보 자동 수집 구현

---

## 🔧 진행 중 작업

*현재 진행 중인 작업이 없습니다.*

## 📋 향후 계획

### StateFlag별 처리 구현 (상황 발생 시)
- [x] CheckIsOrderAsync_InsungOrderManage 구현 (2025-11-07 완료)
- [ ] Command_ChaneTo취소AndDoDelete 구현
- [ ] CheckIsOrderAsync_AssumeKaiUpdated 구현
- [ ] 재적재 로직 구현

---

## 📊 상태 전환 매트릭스 설계

### 🎯 핵심 목표
**Insung 앱의 상태 변화를 감지하여 Kai DB와 다른 외부 앱들을 동기화**

---

### 📊 1. 상태 정의

#### Insung 앱 상태
| 상태 | 설명 | 최종 상태 |
|------|------|-----------|
| 접수 | 주문 접수됨 (기사 미배정) | ❌ |
| 배차 | 기사 배정됨 | ❌ |
| 운행 | 기사 운행 중 | ❌ |
| 완료 | 배송 완료 | ✅ |
| 취소 | 주문 취소됨 | ✅ |
| 대기 | 일시 대기 상태 | ❌ |
| 예약 | 예약 주문 | ❌ |

#### StateFlag (PostgService_Common_OrderState)
| 플래그 | 의미 | 처리 방향 |
|--------|------|-----------|
| `NotChanged` | Kai DB 변화 없음 | **Insung → Kai** (역방향) |
| `Existed_WithSeqno` | 이미 등록됨 | Kai → Insung |
| `Updated_Assume` | Kai DB 업데이트 추정 | Kai → Insung |
| `Updated_Status` | 상태만 변경됨 | Kai → Insung |
| `Updated_Etc` | 기타 필드 변경됨 | Kai → Insung |
| `CompletedExternal` | 외부에서 완료됨 | Kai → Insung (취소) |

---

### 🔄 2. 인성 앱 상태의 실제 의미

#### ⚠️ 중요: Insung 상태 ≠ Kai 상태

| Insung 상태 | 실제 의미 | 기사 확정? | Kai 상태 매핑 |
|-------------|----------|-----------|--------------|
| 접수 | 주문 등록됨, 기사 미배정 | ❌ | **접수** |
| 배차 | 기사가 "관심 있음" 표시 (확정 아님) | ❌ | **접수** |
| 운행 | 배달 수행 의사 표시 (40초 내 취소 가능) | ⏱️ | **접수** (40초 이내) |
| 운행 | 40초 경과 → 기사 확정 | ✅ | **배차** (40초 경과) |
| 완료 | 배송 완료 | ✅ | **완료** |
| 취소 | 주문 취소 | - | **취소** |

#### 핵심 규칙
```
Kai "접수" = Insung "접수" OR "배차" OR "운행(40초 이내)"
Kai "배차" = Insung "운행(40초 경과)"
Kai "완료" = Insung "완료"
Kai "취소" = Insung "취소"
```

---

### 🔄 3. 상태 전환 시나리오

#### A. Kai → Insung (현재 구현됨 ✅)
**함수**: `CheckIsOrderAsync_AssumeKaiUpdated`

| From (Kai) | To (Insung) | 액션 | useRepeat |
|------------|-------------|------|-----------|
| 취소 | 접수 | 팝업 열고 상태 전환 | true (10회) |
| 대기 | 접수 | 팝업 열고 상태 전환 | true (10회) |
| 취소 | 대기 | 팝업 열고 상태 전환 | false (1회) |
| 접수 | 대기 | 팝업 열고 상태 전환 | true (10회) |
| 배차 | 대기 | 팝업 열고 상태 전환 | true (10회) |
| 접수 | 취소 | 팝업 열고 상태 전환 | true (10회) |
| 배차 | 취소 | 팝업 열고 상태 전환 | true (10회) |
| 운행 | 취소 | 팝업 열고 상태 전환 | true (10회) |
| 예약 | 취소 | 팝업 열고 상태 전환 | false (1회) |
| 완료 | 취소 | 팝업 열고 상태 전환 | false (1회) |
| 대기 | 취소 | 팝업 열고 상태 전환 | false (1회) |
| 접수 | 접수 | 필드만 업데이트 | true (10회) |
| 배차 | 배차 | 필드만 업데이트 | true (10회) |
| 취소 | 취소 | 필드만 업데이트 | false (1회) |
| 대기 | 대기 | 필드만 업데이트 | false (1회) |

---

#### B. Insung → Kai (구현 필요 ⚠️)
**함수**: `CheckIsOrderAsync_KaiSameInsungIfChanged`

##### 시나리오 1: Insung "접수 → 배차" (기사 관심 표시)
**Kai 상태**: 접수 유지 (변화 없음)

| 단계 | 액션 | 함수/로직 |
|------|------|-----------|
| 1 | 상태 확인 | Kai="접수", Insung="배차" → 정상 (매핑 일치) |
| 2 | Kai DB | 업데이트 안 함 |
| 3 | 다른 앱 | 아무 동작 안 함 |
| 4 | 큐 관리 | `SuccessAndReEnqueue` (계속 모니터링) |

##### 시나리오 2: Insung "배차 → 운행" (배달 수행 의사)
**Kai 상태**: 접수 유지 (아직 40초 경과 전)

| 단계 | 액션 | 함수/로직 |
|------|------|-----------|
| 1 | 타이머 시작 | 운행 진입 시간 기록: `item.RunStartTime = DateTime.Now` |
| 2 | 기사 정보 수집 | `item.DriverPhone` 설정 |
| 3 | Kai DB | 업데이트 안 함 (아직 접수) |
| 4 | 다른 앱 | 아무 동작 안 함 |
| 5 | 큐 관리 | `SuccessAndReEnqueue` (40초 경과 체크 위해) |

##### 시나리오 3: Insung "운행" 40초 경과 (기사 확정!) ⚠️
**Kai 상태**: 접수 → 배차 (확정)

| 단계 | 액션 | 함수/로직 |
|------|------|-----------|
| 1 | 40초 체크 | `DateTime.Now - item.RunStartTime > 40초` |
| 2 | **다른 앱 상태 체크** | Insung2, 화물24시, 원콜의 현재 상태 확인 |
| 3 | **충돌 감지** | 다른 앱도 "운행" 상태? → 수동 선택 필요 |
| 4 | 충돌 없으면 | Kai DB 업데이트 "접수" → "배차" |
| 5 | 다른 앱 취소 | 접수/배차 상태인 앱들만 자동 취소 |
| 6 | 큐 관리 | `SuccessAndReEnqueue` (완료까지 모니터링) |

##### 시나리오 4: Insung "운행 → 접수/배차" (40초 내 취소)
**Kai 상태**: 접수 유지 (변화 없음)

| 단계 | 액션 | 함수/로직 |
|------|------|-----------|
| 1 | 타이머 취소 | `item.RunStartTime = null` |
| 2 | 기사 정보 초기화 | `item.DriverPhone = null` |
| 3 | Kai DB | 업데이트 안 함 (계속 접수) |
| 4 | 다른 앱 | 아무 동작 안 함 |
| 5 | 큐 관리 | `SuccessAndReEnqueue` (계속 모니터링) |

##### 시나리오 5: Insung "운행(확정) → 완료" (배송 완료)
**Kai 상태**: 배차 → 완료

| 단계 | 액션 | 함수/로직 |
|------|------|-----------|
| 1 | Kai DB 업데이트 | "배차" → "완료" |
| 2 | 다른 앱 | 없음 (이미 취소되었을 것) |
| 3 | 큐 관리 | `SuccessAndDestroy` (모니터링 종료) |

##### 시나리오 6: Insung "접수/배차/운행 → 취소" (주문 취소)
**Kai 상태**: 접수 → 취소 OR 배차 → 취소

| 단계 | 액션 | 함수/로직 |
|------|------|-----------|
| 1 | Kai DB 업데이트 | 현재 상태 → "취소" |
| 2 | 다른 앱 취소 | 모든 외부 앱에서 취소 처리 |
| 3 | 큐 관리 | `SuccessAndDestroy` (모니터링 종료) |

---

### 📊 4. 전체 흐름 요약

#### 정상 흐름 (배송 완료)
```
1. Kai DB: 접수 → Insung1 등록
2. Insung1: 접수 → (Kai: 접수 유지)
3. Insung1: 배차 → (Kai: 접수 유지)
4. Insung1: 운행 진입 → (타이머 시작, 기사 정보 수집, Kai: 접수 유지)
5. 40초 경과 → 다른 앱 상태 체크
   - 충돌 없음 → (Kai: 접수 → 배차, 다른 앱 자동 취소)
6. Insung1: 완료 → (Kai: 배차 → 완료, 모니터링 종료)
```

#### 40초 내 취소 흐름
```
1. Kai DB: 접수 → Insung1 등록
2. Insung1: 접수 → (Kai: 접수 유지)
3. Insung1: 배차 → (Kai: 접수 유지)
4. Insung1: 운행 진입 → (타이머 시작, 기사 정보 수집, Kai: 접수 유지)
5. 10초 후 Insung1: 배차로 복귀 → (타이머 리셋, 기사 정보 초기화, Kai: 접수 유지)
6. 다른 앱 계속 유효 (취소 안 됨)
```

#### 취소 흐름
```
1. Kai DB: 접수 → Insung1 등록
2. Insung1: 취소 → (Kai: 접수 → 취소, 다른 앱 취소, 모니터링 종료)
```

---

## 🏗️ 골격 구현 계획

### 🎯 목표: 상황별 분기만 명확히 + 골격만 구현

---

### 📐 핵심 분기 로직 (5가지만)

```csharp
string kaiState = item.NewOrder.OrderState;
string insungState = dgInfo.sStatus;

// ===== 분기 1: Kai 접수 + Insung 접수/배차 =====
if (kaiState == "접수" && (insungState == "접수" || insungState == "배차"))
{
    // 타이머 리셋 (있었다면)
    if (item.RunStartTime != null)
        item.RunStartTime = null;

    return SuccessAndReEnqueue();
}

// ===== 분기 2: Kai 접수 + Insung 운행 =====
if (kaiState == "접수" && insungState == "운행")
{
    // 2-1. 타이머 시작
    if (item.RunStartTime == null)
    {
        item.RunStartTime = DateTime.Now;
        return SuccessAndReEnqueue();
    }

    // 2-2. 타이머 체크
    TimeSpan elapsed = DateTime.Now - item.RunStartTime.Value;
    if (elapsed.TotalSeconds >= 40)
    {
        // 40초 경과! → Kai 배차로 업데이트 + 다른 앱 처리
        // TODO: 충돌 체크 (Phase 2에서 추가)
        await UpdateKaiStateAsync(item, "배차");
        await CancelOtherAppsAsync(item, ctrl);
        item.RunStartTime = null;
        return SuccessAndReEnqueue();
    }

    return SuccessAndReEnqueue();
}

// ===== 분기 3: Kai 배차 + Insung 완료 =====
if (kaiState == "배차" && insungState == "완료")
{
    await UpdateKaiStateAsync(item, "완료");
    return SuccessAndDestroy("배송 완료");
}

// ===== 분기 4: Insung 취소 =====
if (insungState == "취소")
{
    await UpdateKaiStateAsync(item, "취소");
    await CancelOtherAppsAsync(item, ctrl);
    return SuccessAndDestroy("주문 취소");
}

// ===== 분기 5: 미정의 (에러) =====
return FailureAndDiscard($"미정의: Kai={kaiState}, Insung={insungState}");
```

---

### 🏗️ 골격 함수 (3개만)

#### 1. CheckIsOrderAsync_KaiSameInsungIfChanged (메인)
```csharp
public async Task<CommonResult_AutoAllocProcess> CheckIsOrderAsync_KaiSameInsungIfChanged(
    AutoAllocModel item,
    CommonResult_AutoAllocDatagrid dgInfo,
    CancelTokenControl ctrl)
{
    // 위의 5가지 분기 로직 구현
    // TODO는 최소화
}
```

#### 2. UpdateKaiStateAsync (헬퍼)
```csharp
private async Task<bool> UpdateKaiStateAsync(AutoAllocModel item, string newState)
{
    StdResult_Int result = await CommonVars.s_SrGClient.SrResult_OnlyOrderState_UpdateRowAsync_Today(
        item.NewOrder,
        newState
    );

    if (result.nResult > 0)
    {
        Debug.WriteLine($"  → Kai DB 업데이트 성공: {item.NewOrder.OrderState} → {newState}");
        return true;
    }
    else
    {
        Debug.WriteLine($"  → Kai DB 업데이트 실패: {result.sErrNPos}");
        return false;
    }
}
```

#### 3. CancelOtherAppsAsync (스텁)
```csharp
private async Task CancelOtherAppsAsync(AutoAllocModel item, CancelTokenControl ctrl)
{
    Debug.WriteLine($"[CancelOtherAppsAsync] 다른 앱 취소 시작: KeyCode={item.KeyCode}");

    // TODO: Insung2 취소
    if (!string.IsNullOrEmpty(item.NewOrder.Insung2))
    {
        Debug.WriteLine($"  - Insung2 취소: {item.NewOrder.Insung2} [TODO]");
    }

    // TODO: 화물24시 취소
    if (!string.IsNullOrEmpty(item.NewOrder.Hwamul24))
    {
        Debug.WriteLine($"  - 화물24시 취소: {item.NewOrder.Hwamul24} [TODO]");
    }

    // TODO: 원콜 취소
    if (!string.IsNullOrEmpty(item.NewOrder.OneCall))
    {
        Debug.WriteLine($"  - 원콜 취소: {item.NewOrder.OneCall} [TODO]");
    }

    Debug.WriteLine($"[CancelOtherAppsAsync] 다른 앱 취소 완료 (스텁)");
}
```

---

### 📋 구현 순서 (단계별)

#### Phase 1: 골격 구현 ✅ (완료)
**목표**: 분기 로직만 동작하게

1. **InsungsAct_RcptRegPage.cs**에 함수 추가
   - `CheckIsOrderAsync_KaiSameInsungIfChanged` (5가지 분기만)
   - `UpdateKaiStateAsync` (헬퍼)
   - `CancelOtherAppsAsync` (스텁, TODO만)

2. **NwInsung01.cs** Line 577 주석 해제
   ```csharp
   resultAuto = await m_Context.RcptRegPageAct.CheckIsOrderAsync_KaiSameInsungIfChanged(
       foundItem, dgInfoNotChanged, ctrl);
   ```

3. **빌드 및 기본 테스트**
   - 컴파일 에러 없이 빌드
   - 로그 출력 확인 (분기 진입 확인)

---

#### Phase 2: 실제 동작 테스트 (다음 단계)
**목표**: 각 분기가 실제로 동작하는지 확인

1. 분기 1 테스트: Kai 접수 + Insung 접수/배차
   - 로그: "접수 유지, 모니터링 계속"

2. 분기 2 테스트: 40초 타이머
   - 로그: "운행 진입 - 타이머 시작"
   - 로그: "운행 중 - 경과 시간: X초"
   - 로그: "40초 경과! Kai DB 업데이트"

3. 분기 3/4/5 테스트

---

#### Phase 3: TODO 채워나가기 (시행착오)
**실제 환경에서 발견되는 문제들을 하나씩 해결**

1. **CancelOtherAppsAsync 구현**
   - Insung2 취소 로직
   - 화물24시 취소 로직
   - 원콜 취소 로직

2. **충돌 감지 추가** (분기 2에 추가)
   ```csharp
   if (elapsed.TotalSeconds >= 40)
   {
       // TODO: 다른 앱 상태 체크
       // TODO: 충돌 있으면 수동 선택
       // TODO: 충돌 없으면 자동 취소
   }
   ```

3. **예외 처리**
   - DB 업데이트 실패 시 재시도
   - 타임아웃 처리
   - 네트워크 오류 처리

---

#### Phase 4: 고급 기능 (나중에)
**충돌 처리, 수동 선택 등**

1. GetOtherAppStatesAsync 구현
2. ManualSelectionDialog WPF 대화상자
3. ShowManualSelectionDialogAsync 구현
4. CancelUnselectedAppsAsync 구현

---

## 📌 주요 상수 및 참고

### Datagrid 컬럼 (InsungsAct_RcptRegPage.cs Line 88-90)
- `c_nCol상태 = 1`
- `c_nCol주문번호 = 2`
- `c_nColForClick = 3`

### Datagrid 구조
- y=0: 헤더
- y=1: 빈 행 (Empty Row)
- y=2~: 데이터 행

### 대기 시간
- `c_nWaitShort`: 짧은 대기
- `c_nWaitNormal`: 보통 대기
- `c_nWaitLong = 250ms`: 긴 대기

### 재시도 횟수
- `c_nRepeatShort = 3`: 3회 재시도
- `c_nRepeatNormal = 10`: 10회 재시도

---

## 🔗 최근 커밋

- `d472584` - refactor: Cargo24 코드 품질 개선 및 MainWnd 초기화 안정성 향상 (2025-11-20)
- `81f169b` - docs: 2025-11-19 작업 기록 추가 (Cargo24 헤더 캡처) (2025-11-19)
- `f66f223` - feat: Cargo24 Datagrid 헤더 캡처 및 컬럼 경계 검출 구현 (2025-11-19)
- `18b08ba` - feat: 인성 운행 상태 40초 타이머 및 기사 정보 자동 수집 구현 (2025-11-08)
- `a718918` - feat: Insung 주문 상태 관리 함수 구현 (Phase 1 - 골격 구현) (2025-11-07)
- `45bf78c` - fix: SignalR 주문 업데이트 처리 로직 개선 (2025-11-06)
- `7fc974b` - refactor: OFR 함수 오버로드 패턴 적용 및 코드 간소화 (2025-11-04)
- `f78e473` - feat: ReEnqueue 함수 개선 및 Skip case 처리 추가
- `f99e928` - feat: Region 5-3 페이지별 검색 루프 구조 구현
- `40a2161` - feat: Region 5-1, 5-2 구현 (기존 주문 관리)

---
