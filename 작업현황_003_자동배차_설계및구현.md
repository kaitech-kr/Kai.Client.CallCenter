# 자동배차 로직 설계 및 구현 (2025-10-19)

## 작업 개요
NwInsung02 자동배차 로직 구현을 위한 분석, 설계, 구현 작업

---

## 1. 세션 시작: 기존 작업 현황 분석

### 완료된 작업 (작업현황_002 확인)
- ✅ NwInsung02 초기화 구현 완료
- ✅ StatusBtn Down 상태 OFR 추가
- ✅ InsungsAct_RcptRegPage 초기화 완료

### 다음 작업 계획
백업 파일 `Backup\Networks\NwInsung02.cs`의 AutoAllocAsync 함수 (Lines 213-503) 분석 및 구현

---

## 2. AutoAllocAsync 함수 분석

### 함수 구조 (5단계)
```
AutoAllocAsync(long lAllocCount, CancelTokenControl ctrl)
│
├─ 1. 사전작업
│   └─ TopMost 설정
│
├─ 2. Local Variables 초기화
│   ├─ listOrg: AutoAllocCtrl.listForInsung02
│   ├─ listCreated: 신규 오더
│   └─ listEtcGroup: 기존 오더 (Updated, NotChanged 등)
│
├─ 3. Check Datagrid
│   └─ Datagrid 윈도우 존재 확인
│
├─ 4. Created Order 처리 (신규)
│   └─ CheckIsOrderAsync_AssumeKaiNewOrder
│
└─ 5. Updated, NotChanged Order 처리
    ├─ 5-1. 조회버튼 클릭 + 총계 확인
    ├─ 5-2. 오더 총갯수/페이지 산정
    └─ 5-3. Kai갯수만큼 작업
        ├─ FindDatagridPageNIndex
        └─ StateFlag별 처리
```

### 인성1과 인성2 차이점
**핵심: 단 3곳만 다름!**

| 항목 | 인성1 | 인성2 |
|------|-------|-------|
| Debug 로그 | `Insung01` | `Insung02` |
| 작업 리스트 | `AutoAllocCtrl.listForInsung01` | `AutoAllocCtrl.listForInsung02` |
| KeyCode 필드 | `item.TbNewOrder.Insung1` | `item.TbNewOrder.Insung2` |

**결론**: 데이터베이스 필드명만 다르고 로직은 완전 동일

---

## 3. 버튼 클릭 패턴 분석

### 질문
Click조회버튼Async처럼 버튼별로 개별 함수를 만드는 게 타당한가?

### 분석 결과: ✅ 개별 함수가 타당

#### Click조회버튼Async - 복합 작업
```csharp
1. 조회 버튼 클릭
2. WaitPanLoadedAsync (Datagrid 로딩 대기)
3. GetWindowCaption (총계 읽기)
4. 재시도 로직
→ 단순 클릭이 아닌 "결과 반환" 함수
```

#### ClickEmptyRowAsync - 특수 로직
```csharp
1. Empty Row 좌표 계산 (DG오더_RelChildRects[0, 1])
2. 밝기 변화 감지로 클릭 확인
3. 재시도 로직
→ 단순 클릭이 아닌 "검증 포함" 함수
```

### 결론
- 복합 작업 (클릭 + 대기 + 검증 + 결과)
- 재사용성 높음
- 결과 반환 필요
→ **개별 함수로 구현하는 것이 타당**

---

## 4. Helper 함수 구현 (1차)

### 구현 완료 함수 (InsungsAct_RcptRegPage.cs Lines 1813-1941)

#### 1. WaitPanLoadedAsync (private)
**목적**: Datagrid 로딩 완료 대기 (Pan 상태 변화 감지)

**로직**:
1. Pan이 나타날 때까지 대기 (최대 100ms)
2. Pan이 사라질 때까지 대기 (로딩 완료)
3. 시간 초과 시 Fail 반환

**반환**: Success (정상), Skip (Pan 없음), Fail (시간 초과)

#### 2. Click조회버튼Async (public)
**목적**: 조회 버튼 클릭 후 총계 읽기

**로직**:
1. 조회 버튼 클릭
2. WaitPanLoadedAsync 호출
3. CallCount_hWnd총계에서 Caption 읽기
4. 재시도 (c_nRepeatShort)

**반환**: StdResult_String (총계 문자열)

#### 3. ClickEmptyRowAsync (public)
**목적**: Empty Row 클릭 (선택 해제용)

**로직**:
1. Empty Row 좌표 계산 ([0, 1] 셀)
2. SafeMousePost_ClickLeft_ptRel_WaitBrightChange 호출
3. 밝기 변화 감지로 클릭 성공 확인
4. 재시도

**반환**: bool (성공 여부)

### 빌드 결과
✅ **컴파일 에러 없음**
- FormCtrl 프로젝트의 기존 리소스 이슈만 있음 (내 코드와 무관)

---

## 5. 자동배차 진입 로직 분석

### 백업 파일 구조 (CtrlOtherApps.cs)

```
StartAsync()
    ↓
Task.Run(() => AutoAllocLoopAsync())
    ↓
AutoAllocLoopAsync() - 무한 루프
    │
    ├─ Stopwatch.Restart()
    │
    ├─ NwInsung01.AutoAllocAsync(lAllocCount, ctrlCancelToken)
    │
    ├─ NwInsung02.AutoAllocAsync(lAllocCount, ctrlCancelToken)
    │
    ├─ Stopwatch.Stop()
    │
    └─ Delay 보정 (최소 5초 유지)
```

### 핵심 코드
```csharp
public async Task AutoAllocLoopAsync()
{
    Stopwatch stopwatch = new();
    const int nMinWorkingMiliSec = 5000; // 최소 5초

    for (lAutoAllocCount = 1; ; lAutoAllocCount++)
    {
        stopwatch.Restart();

        var insung1 = NwInsung01.Instance;
        if (insung1 != null)
            resultSts = await insung1.AutoAllocAsync(lAllocCount, ctrlCancelToken);

        var insung2 = NwInsung02.Instance;
        if (insung2 != null)
            resultSts = await insung2.AutoAllocAsync(lAllocCount, ctrlCancelToken);

        stopwatch.Stop();
        nDelay = stopwatch.ElapsedMilliseconds < nMinWorkingMiliSec
            ? nMinWorkingMiliSec - (int)stopwatch.ElapsedMilliseconds
            : 0;

        if (nDelay > 0)
            await Task.Delay(nDelay, ctrlCancelToken.Token);
    }
}
```

---

## 6. 기존 구조 문제점 및 개선안

### ❌ 문제점 1: 이중 Singleton 패턴
```csharp
// CtrlOtherApps - Singleton
public static CtrlOtherApps Instance { get; }

// NwInsung01/02 - 또 Singleton
public static NwInsung01 Instance { get; }
```

**문제**:
- 불필요한 복잡성
- ExternalAppController는 이미 인스턴스 패턴 사용 중

**개선**: ExternalAppController 인스턴스만 사용

---

### ❌ 문제점 2: m_ListApps 미활용
```csharp
// 리스트를 만들어놨는데 안 씀
public IReadOnlyList<IExternalApp> Apps => m_ListApps.AsReadOnly();

// Instance로 직접 접근
var insung1 = NwInsung01.Instance;
var insung2 = NwInsung02.Instance;
```

**개선안**:
```csharp
// foreach로 간단하게 처리
foreach (var app in m_ListApps)
{
    await app.AutoAllocAsync(m_lAutoAllocCount, m_CtrlCancelToken);
}
```

**장점**:
- 확장성: 앱 추가 시 코드 수정 불필요
- 간결성: null 체크 불필요

---

### ❌ 문제점 3: 에러 처리 없음
```csharp
resultSts = await insung1.AutoAllocAsync(...);
// resultSts를 받지만 아무것도 안함!
// 에러가 발생해도 다음 루프로 계속 진행
```

**개선**: 에러 로깅 + try-catch

---

### ❌ 문제점 4: static CancelToken
```csharp
public static CancelTokenControl ctrlCancelToken = new();
```

**문제**: 전역 상태

**개선**: 인스턴스 변수

---

### ❌ 문제점 5: WaitIfPausedOrCancelledAsync 중복
```csharp
// 인성1 전
await ctrlCancelToken.WaitIfPausedOrCancelledAsync();
// 인성2 전
await ctrlCancelToken.WaitIfPausedOrCancelledAsync();
```

**개선**: 루프 시작 시 한 번만

---

### ✅ 개선안: 리스트 활용 + 에러 처리

```csharp
// IExternalApp 인터페이스 확장
public interface IExternalApp : IDisposable
{
    bool IsUsed { get; }
    string AppName { get; }
    Task<StdResult_Status> InitializeAsync();
    void Shutdown();
    Task<StdResult_Status> AutoAllocAsync(long lAllocCount, CancelTokenControl ctrl); // ⭐ 추가
}

// ExternalAppController
public async Task AutoAllocLoopAsync()
{
    Stopwatch stopwatch = new();
    const int nMinWorkingMiliSec = 5000;

    for (m_lAutoAllocCount = 1; ; m_lAutoAllocCount++)
    {
        try
        {
            // ⭐ 루프 시작 시 한 번만
            await m_CtrlCancelToken.WaitIfPausedOrCancelledAsync();

            stopwatch.Restart();

            // ⭐ 리스트 활용 - 확장 가능
            foreach (var app in m_ListApps)
            {
                try
                {
                    var result = await app.AutoAllocAsync(m_lAutoAllocCount, m_CtrlCancelToken);

                    // ⭐ 에러 로깅
                    if (result.Result != StdResult.Success)
                    {
                        Debug.WriteLine($"[{app.AppName}] AutoAlloc 실패: {result.sErrNPos}");
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"[{app.AppName}] AutoAlloc 예외: {ex.Message}");
                }
            }

            // Delay 보정
            stopwatch.Stop();
            int nDelay = stopwatch.ElapsedMilliseconds < nMinWorkingMiliSec
                ? nMinWorkingMiliSec - (int)stopwatch.ElapsedMilliseconds
                : 0;

            if (nDelay > 0)
                await Task.Delay(nDelay, m_CtrlCancelToken.Token);

            Debug.WriteLine($"[AutoAlloc {m_lAutoAllocCount}] Elapsed={stopwatch.ElapsedMilliseconds}ms, Delay={nDelay}ms");
        }
        catch (OperationCanceledException)
        {
            Debug.WriteLine("[AutoAllocLoop] 취소됨");
            return;
        }
    }
}
```

**개선 요약**:

| 항목 | 기존 | 개선 |
|------|------|------|
| Singleton | CtrlOtherApps + NwInsung01/02 이중 | ExternalAppController만 |
| 앱 접근 | Instance + null 체크 | m_ListApps foreach |
| 확장성 | 앱 추가 시 코드 수정 | foreach로 자동 |
| 에러 처리 | 무시 | 로깅 + try-catch |
| CancelToken | static | 인스턴스 변수 |
| Pause 체크 | 각 앱마다 | 루프 시작 시 한 번 |

---

## 7. 취소/Pause 체크 패턴 가이드 ⭐⭐⭐

### 문제점: 체크 포인트 불명확 + 중복

```csharp
// 중복이 너무 많음!
for (...)
{
    await ctrl.WaitIfPausedOrCancelledAsync(); // 1번
    await insung1.AutoAllocAsync(...);

    await ctrl.WaitIfPausedOrCancelledAsync(); // 2번
    await insung2.AutoAllocAsync(...);
}

// AutoAllocAsync 내부
await ctrl.WaitIfPausedOrCancelledAsync(); // 3번

for (int i = 0; i < count; i++)
{
    await ctrl.WaitIfPausedOrCancelledAsync(); // 4번
    // ...
}

// Click조회버튼Async 내부
for (int i = 0; i < c_nRepeatShort; i++)
{
    await ctrl.WaitIfPausedOrCancelledAsync(); // 5번
    // ...
}
```

**문제**: 1,2,3은 거의 동시에 체크 → 불필요한 중복

---

### ✅ 개선 원칙: 레벨별 책임 분담

```
┌────────────────────────────────────────────────────┐
│ Level 1: Loop (AutoAllocLoopAsync)                 │
│ - 루프 시작 시 1번만 체크                           │
│ - Task.Delay에 Token 전달                          │
├────────────────────────────────────────────────────┤
│ Level 2: Task (AutoAllocAsync)                     │
│ - 함수 진입 시 체크 안함 (Loop에서 이미 체크)      │
│ - 내부 긴 루프가 있으면 루프마다 체크              │
├────────────────────────────────────────────────────┤
│ Level 3: Action (Click조회버튼Async 등)            │
│ - 루프가 있으면 루프마다 체크                      │
│ - Task.Delay에 Token 전달                          │
├────────────────────────────────────────────────────┤
│ Level 4: Helper (짧은 작업)                        │
│ - 체크 안함                                         │
└────────────────────────────────────────────────────┘
```

---

### 체크 포인트 결정 기준

| 상황 | 체크 여부 | 이유 |
|------|-----------|------|
| **무한 루프 시작** | ✅ 필수 | 응답성 |
| **긴 루프 (100+ 반복)** | ✅ 필수 | 취소 기회 제공 |
| **짧은 루프 (10 이하)** | ❌ 불필요 | 곧 끝남 |
| **함수 진입 시** | ❌ 불필요 | 상위에서 체크 |
| **Task.Delay 전** | ❌ 불필요 | Token 전달로 해결 |
| **긴 작업 전 (3초+)** | ✅ 권장 | 응답성 |
| **Helper 함수** | ❌ 불필요 | 짧은 작업 |

---

### 원칙 1: Task.Delay는 항상 Token 전달

```csharp
// ✅ Good - 취소 시 즉시 반응
await Task.Delay(ms, ctrl.Token);

// ❌ Bad - 취소해도 ms만큼 무조건 대기
await Task.Delay(ms);
```

---

### 원칙 2: 루프 레벨별 책임

#### Level 1: 무한 루프 (AutoAllocLoopAsync)
```csharp
for (m_lAutoAllocCount = 1; ; m_lAutoAllocCount++)
{
    // ✅ 루프 시작 시 한 번만
    await m_CtrlCancelToken.WaitIfPausedOrCancelledAsync();

    foreach (var app in m_ListApps)
    {
        // ❌ 여기서 체크 안함 (바로 위에서 했음)
        await app.AutoAllocAsync(...);
    }

    // ✅ Token 전달
    await Task.Delay(nDelay, m_CtrlCancelToken.Token);
}
```

#### Level 2: 긴 루프 (AutoAllocAsync)
```csharp
public async Task<StdResult_Status> AutoAllocAsync(...)
{
    // ❌ 진입 시 체크 안함 (Loop에서 이미 체크)

    // Created Order 처리 - 긴 루프 (몇백 개)
    for (int i = listCreated.Count; i > 0; i--)
    {
        // ✅ 긴 루프는 매 반복마다 체크
        await ctrl.WaitIfPausedOrCancelledAsync();

        await CheckIsOrderAsync_AssumeKaiNewOrder(item, ctrl);
    }

    // Datagrid 체크 - 짧은 루프 (10번)
    for (int i = 0; i < c_nRepeatShort; i++)
    {
        // ❌ 짧은 루프는 체크 안함
        if (조건) break;

        // ✅ Token 전달
        await Task.Delay(100, ctrl.Token);
    }
}
```

#### Level 3: Action (Click조회버튼Async)
```csharp
public async Task<StdResult_String> Click조회버튼Async(CancelTokenControl ctrl)
{
    for (int i = 0; i < CommonVars.c_nRepeatShort; i++) // 10번
    {
        // ✅ 루프마다 체크 (UI 응답성)
        await ctrl.WaitIfPausedOrCancelledAsync();

        Simulation_Mouse.SafeMousePost_ClickLeft(...);

        // ✅ Token 전달
        await Task.Delay(CommonVars.c_nWaitNormal, ctrl.Token);
    }
}
```

---

### 원칙 3: 함수 진입 시 체크 안함

**이유**: 상위 레벨에서 이미 체크했다고 가정 (중복 제거)

```csharp
// ❌ Bad - 중복
public async Task AutoAllocAsync(...)
{
    await ctrl.WaitIfPausedOrCancelledAsync(); // 불필요! Loop에서 이미 체크
    // ...
}

// ✅ Good
public async Task AutoAllocAsync(...)
{
    // 진입 시 체크 안함
    // 내부 긴 루프에서만 체크
}
```

---

### 원칙 4: 예외 처리 필수

```csharp
try
{
    await ctrl.WaitIfPausedOrCancelledAsync();
    // 작업
    await Task.Delay(ms, ctrl.Token);
}
catch (OperationCanceledException)
{
    // 정상 종료 처리
    Debug.WriteLine("작업 취소됨");
    return new StdResult_Status(StdResult.Skip, "작업 취소됨");
}
```

---

### 개선 전/후 비교

#### ❌ Before: 중복 체크
```csharp
// AutoAllocLoopAsync
for (...)
{
    await ctrl.WaitIfPausedOrCancelledAsync(); // 1번
    await insung1.AutoAllocAsync(...);         // 내부에서 또 체크 (2번)

    await ctrl.WaitIfPausedOrCancelledAsync(); // 3번
    await insung2.AutoAllocAsync(...);         // 내부에서 또 체크 (4번)
}
// 총 4번 체크 (불필요한 중복)
```

#### ✅ After: 레벨별 책임
```csharp
// AutoAllocLoopAsync
for (...)
{
    await ctrl.WaitIfPausedOrCancelledAsync(); // 1번만

    foreach (var app in m_ListApps)
    {
        await app.AutoAllocAsync(...); // 진입 시 체크 안함
    }
}

// AutoAllocAsync 내부 - 긴 루프만 체크
for (int i = listCreated.Count; i > 0; i--) // 몇백 개
{
    await ctrl.WaitIfPausedOrCancelledAsync(); // 긴 루프는 체크
    // ...
}
```

---

## 8. 다음 작업 계획

### 우선순위 1: 자동배차 진입 구조 구현
1. **ExternalAppController에 추가**
   - `CancelTokenControl m_CtrlCancelToken` 변수
   - `StartAutoAlloc()` 메서드
   - `AutoAllocLoopAsync()` 메서드 (개선된 구조)

2. **IExternalApp 인터페이스 확장**
   - `AutoAllocAsync` 메서드 추가

3. **NwInsung02에 AutoAllocAsync 기본 구조 추가**
   - 빈 구조로 일단 추가 (StdResult.Success 반환)
   - 빌드 확인

### 우선순위 2: AutoAllocAsync 내부 로직 구현
1. 나머지 Helper 함수 구현 (하나씩 테스트)
   - FindDatagridPageNIndex
   - CheckIsOrderAsync_AssumeKaiNewOrder
   - 기타 복잡한 함수들 (블록 단위)

2. AutoAllocAsync 전체 로직 구현

### 우선순위 3: 테스트 및 검증
- 빌드 확인
- 로직 검증
- 취소/Pause 동작 확인

---

## 9. 참고사항

### 빌드 상태
- ✅ Helper 함수 3개 추가 후 컴파일 성공
- ❌ FormCtrl 프로젝트 기존 리소스 이슈 (내 코드와 무관)

### 리팩토링 원칙 적용
- ✅ Context 패턴 (m_Context, m_RcptPage, m_FileInfo)
- ✅ Debug 로깅 추가
- ✅ 명확한 XML 문서 주석
- ✅ 취소/Pause 체크 원칙 (레벨별 책임)

### 설계 결정 사항
1. 버튼 클릭: 개별 함수로 구현 (복합 작업이므로)
2. 자동배차 구조: m_ListApps foreach 활용 (확장성)
3. 에러 처리: 로깅 + try-catch (안정성)
4. 취소/Pause: 레벨별 책임 분담 (중복 제거)

---

**작업 완료 일시**: 2025-10-19
**다음 세션 주제**: 개선된 자동배차 구조 구현 및 테스트
