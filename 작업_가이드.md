# 작업 가이드

## 📋 완료된 작업

### 1. 접수등록 - 요금 및 오더메모 입력 (2025-10-29)
**파일**: `InsungsAct_RcptRegPage.cs`

**구현 내용**:
- 요금 입력 (기본요금, 추가금액, 할인금액, 탁송료)
  - 보안상 키보드 시뮬레이션만 사용 (SetWindowText 불가)
  - `ResgistAndVerify요금Async` 함수로 입력 및 검증
- 오더메모 입력 (형식: `{KeyCode}/{OrderMemo}`)
  - `WriteAndVerifyEditBoxAsync` 사용

**핵심 함수**:
- `ResgistAndVerify요금Async` (Line 3739-3765): 요금 필드 입력/검증, 3회 재시도
- `WriteAndVerifyEditBoxAsync` (Line 3011-3071): EditBox 입력/검증

### 2. 접수등록 - 첫 로우 선택 검증 (2025-10-30)
**파일**: `InsungsAct_RcptRegPage.cs`

**구현 내용**:
- 첫 로우 선택 검증 (중심 라인 평균 밝기 방식)
  - 선택 시 반전되어 어두워짐 → `평균 밝기 < 배경 밝기 - 10`
- 첫 로우 클릭 함수 개선 (클릭 후 검증 및 재시도)

**핵심 함수**:
- `VerifyFirstRowSelectedAsync` (Line 2541-2603): 중심 라인 평균 밝기로 선택 검증
- `ClickFirstRowAsync` (Line 2482-2539): 클릭 후 검증, 실패 시 재시도

### 3. Datagrid 배경 밝기 측정 및 Region 5-1, 5-3 개선 (2025-11-02)
**파일**:
- `InsungsAct_RcptRegPage.cs`
- `NwInsung01.cs`

**구현 내용**:
1. **배경 밝기 측정 위치 수정**
   - Empty Row의 샘플 포인트를 (3,3)에서 (8,8)로 변경
   - 측정값이 211에서 255로 개선되어 정확도 향상
   - `InsungsAct_RcptRegPage.cs` Line 832

2. **Region 5-1: 총계 읽기 로직 개선**
   - 한 번만 시도하던 로직을 백업 코드처럼 반복 구조로 변경
   - 조회버튼 클릭과 총계 읽기를 `c_nRepeatNormal`회 반복
   - 실패 시 `c_nWaitNormal` 대기 후 재시도
   - `NwInsung01.cs` Line 376-400

3. **Region 5-3: 유효 로우 체크 로직 완성**
   - 페이지별 유효 로우 갯수 측정 구현
   - 밝기 측정 위치: `rects[0, y].Right, rects[0, y].Top + 6`
   - 임계값: `배경 밝기 - 1`
   - 밝기가 임계값 미만이면 유효 로우로 카운트
   - `NwInsung01.cs` Line 465-479

**핵심 로직**:
```csharp
// Region 5-1: 총계 읽기 재시도
for (int i = 0; i < c_nRepeatNormal; i++)
{
    StdResult_Status resultQuery = await Click조회버튼Async(ctrl);
    if (resultQuery.Result == StdResult.Fail) continue;

    sThisTotCount = GetWindowCaption(CallCount_hWnd총계);
    if (!string.IsNullOrEmpty(sThisTotCount)) break;

    await Task.Delay(c_nWaitNormal, ctrl.Token);
}

// Region 5-3: 유효 로우 체크
int nThreshold = nBackgroundBright - 1;
for (int y = 2; y < rects.GetLength(1); y++)
{
    Draw.Point ptCheck = new Draw.Point(rects[0, y].Right, rects[0, y].Top + 6);
    int nCurBright = OfrService.GetPixelBrightness(bmpDG, ptCheck);

    if (nCurBright < nThreshold)
        nValidRows++;
    else
        break;
}
```

### 4. 페이지 검증 및 자동 조정 (2025-11-03)
**파일**:
- `InsungsAct_RcptRegPage.cs`
- `InsungsInfo_File.cs`
- `OfrWork_Commons.cs`
- `NwInsung01.cs`

**구현 내용**:
1. **GetExpectedFirstRowNum 함수** (InsungsAct_RcptRegPage.cs Line 2805-2828)
   - 페이지별 예상 첫 로우 번호 계산 (0-based 인덱스)
   - 마지막 페이지 특수 처리 (나머지 행 계산)
   - public static으로 선언 → 인성1, 인성2 공통 사용

2. **ReadFirstRowNumAsync 함수** (InsungsAct_RcptRegPage.cs Line 2830-2865)
   - OFR로 번호 컬럼(x=0) 실제 첫 번호 읽기
   - bEdit 매개변수로 대화상자 제어 (기본값: false)
   - y=2부터 순차적으로 OFR 시도

3. **VerifyAndAdjustPageAsync 함수** (InsungsAct_RcptRegPage.cs Line 2867-2943)
   - 페이지 검증 및 자동 조정 (재시도 3회)
   - 최소 클릭 최적화: rowClicks > 14이면 역방향 스크롤
   - 페이지/로우 스크롤 구분
   - public 메서드 → 인성1, 인성2 공통 사용

4. **OfrStr_SeqCharAsync 개선** (OfrWork_Commons.cs Line 282, 339)
   - bEdit 매개변수 추가 (기본값: true)
   - `if (bEdit && s_bDebugMode)` 조건 추가

5. **상수 변경** (InsungsInfo_File.cs Line 129)
   - `접수등록Page_DG오더_dataRowCount`를 const로 변경

**핵심 로직**:
```csharp
// 예상 첫 번호 계산
int nExpectedFirstNum = GetExpectedFirstRowNum(nTotRows, pageIdx);

// 페이지 검증 및 자동 조정
StdResult_Status result = await VerifyAndAdjustPageAsync(nExpectedFirstNum, ctrl);
if (result.Result == StdResult.Fail)
    return result;

// 최소 클릭 최적화
if (rowClicks > dataRowCount / 2)
{
    pageClicks += 1;
    rowClicks = dataRowCount - rowClicks;
    bReverse = true;
}
```

### 5. 페이지 캡처 및 주문번호 OFR 구현 (2025-11-03)
**파일**:
- `InsungsAct_RcptRegPage.cs`
- `NwInsung01.cs`

**구현 내용**:
1. **GetValidRowCountAsync 함수** (InsungsAct_RcptRegPage.cs Line 2952-2981)
   - 캡처된 페이지 이미지에서 유효 로우 갯수 측정
   - 밝기 측정으로 실제 데이터 유무 확인
   - 임계값: 배경 밝기 - 1
   - StdResult_Int 반환 (에러 처리 포함)

2. **GetRowSeqnoAsync 함수** (InsungsAct_RcptRegPage.cs Line 2983-3033)
   - 캡처된 페이지 이미지에서 특정 로우의 주문번호 읽기
   - GetBitmapInBitmapFast로 영역 crop
   - bInvertRgb 매개변수로 선택된 행 RGB 반전 처리
   - OfrStr_SeqCharAsync로 주문번호 인식
   - StdResult_String 반환

3. **페이지 캡처 및 처리** (NwInsung01.cs Line 447-514)
   - 페이지별 데이터그리드 전체 캡처 (재시도 3회)
   - try-finally로 Bitmap 안전 해제
   - 유효 로우 갯수 얻기
   - 마지막 페이지 startIndex 자동 계산
   - 첫 페이지 첫 로우 자동 선택
   - 로우별 주문번호 OFR 및 Debug 출력

**핵심 로직**:
```csharp
// 페이지 캡처 (재시도)
for (int j = 0; j < CommonVars.c_nRepeatShort; j++)
{
    bmpPage = OfrService.CaptureScreenRect_InWndHandle(m_Context.MemInfo.RcptPage.DG오더_hWnd);
    if (bmpPage != null) break;
    await Task.Delay(CommonVars.c_nWaitShort, ctrl.Token);
}

// 유효 로우 갯수
StdResult_Int resultInt = await m_Context.RcptRegPageAct.GetValidRowCountAsync(bmpPage);

// 마지막 페이지 startIndex 계산
int remainder = nThisTotCount % InsungsInfo_File.접수등록Page_DG오더_dataRowCount;
int startIndex = (pageIdx == nTotPage - 1 && remainder != 0) ?
    InsungsInfo_File.접수등록Page_DG오더_dataRowCount - remainder : 0;

// 로우별 주문번호 읽기
for (int i = startIndex, y = i + 2; i < resultInt.nResult; i++, y++)
{
    // 첫 페이지 첫 로우 자동 선택
    if (pageIdx == 0 && i == startIndex) { /* 클릭 */ }

    // 주문번호 OFR
    Draw.Rectangle rectSeqno = rects[c_nCol주문번호, y];
    bool bInvertRgb = (pageIdx == 0 && y == 2);
    StdResult_String resultSeqno = await GetRowSeqnoAsync(bmpPage, rectSeqno, bInvertRgb);
}
```

**주요 개선점**:
- 페이지당 1회 캡처로 성능 최적화 (셀마다 캡처 X)
- 마지막 페이지 빈 로우 자동 건너뜀
- 선택된 행 RGB 반전 자동 처리
- try-finally로 메모리 누수 방지

---

## 🔧 진행 중 작업

### 1. RightSliding 재귀 로직 개선
**목적**: "123456789"처럼 많은 문자가 붙어있을 때 재귀 처리

**현재 문제**:
- RightSliding 2단계에서 나머지 영역 통째로 DB 검색
- 여러 문자 붙어있으면 실패 → "☒9" 부분 실패 결과

**해결 방안**: 가로/세로 비율 기준 (1.25배)
```csharp
if (width <= height * 1.25)
{
    // 단일 문자 가능성 → 전경/배경 방식 먼저 시도
    // 실패 시 → 재귀 RightSliding
}
else
{
    // 여러 문자 확실 → 바로 재귀 RightSliding
}
```

**수정 위치**:
- 파일: `Ofr_CharSet_Core.cs`
- 함수: `RecognizeCharSetAsync_RightSliding`
- Line: 584-655 (2단계 부분)

### 2. Region 5-3 - 기존 주문 처리
**목표**: 페이지별로 순회하며 리스트 전체 검사

**완료 상태**:
- ✅ 페이지별 검증 및 캡처 (NwInsung01.cs Line 437-459)
- ✅ GetValidRowCountAsync 함수 구현
- ✅ GetRowSeqnoAsync 함수 구현
- ✅ 마지막 페이지 startIndex 자동 계산
- ✅ 첫 페이지 첫 로우 자동 선택
- ✅ 로우별 주문번호 OFR (테스트 완료)

**남은 작업**:

**우선순위 1: listEtcGroup 순회 및 주문번호 매칭**
- [ ] listEtcGroup 역순 순회 구현
- [ ] 읽은 주문번호와 listEtcGroup의 Insung1 비교
- [ ] 찾으면 해당 항목의 StateFlag에 따라 처리
- **구현 위치**: NwInsung01.cs Line 481 for 루프 내부
- **로직**:
  ```csharp
  for (int i = startIndex, y = i + 2; i < resultInt.nResult; i++, y++)
  {
      // 주문번호 읽기
      string seqno = resultSeqno.strResult;

      // listEtcGroup에서 찾기 (역순)
      for (int listIdx = listEtcGroup.Count - 1; listIdx >= 0; listIdx--)
      {
          if (listEtcGroup[listIdx].NewOrder.Insung1 == seqno)
          {
              // 찾음 → StateFlag별 처리
              break;
          }
      }
  }
  ```

**우선순위 2: StateFlag별 처리 구현**
```csharp
// 현재 페이지 캡처 → 행별 주문번호 읽기 → 찾으면 행 인덱스 저장
for (int rowIdx = 2; rowIdx < nRowsPerPage + 2; rowIdx++)
{
    string sPageSeqno = OFR로_주문번호_읽기(bmpPage, rowIdx);
    if (sPageSeqno == sSeqNo) { /* 찾음 */ }
}
```

**우선순위 4: StateFlag 처리** (Line 438-449)
- [ ] CheckIsOrderAsync_KaiSameInsungIfChanged 구현
- [ ] Command_ChaneTo취소AndDoDelete 구현
- [ ] CheckIsOrderAsync_AssumeKaiUpdated 구현
- [ ] 재적재 로직 구현

**핵심 알고리즘**:
```csharp
// 페이지별 순회
for (int pageIdx = 1; pageIdx <= nTotPage; pageIdx++)
{
    // 1. 페이지 이동
    // 2. 페이지 캡처

    // 리스트 전체 검사 (역순 - 삭제 안전)
    for (int no = listEtcGroup.Count; no > 0; no--)
    {
        // 3. 현재 페이지에서 주문번호 찾기
        // 4. 찾으면 OFR로 상태 읽기
        // 5. StateFlag별 처리
        // 6. 재적재 또는 삭제
        listEtcGroup.RemoveAt(index);
    }

    // 7. 조기 탈출
    if (listEtcGroup.Count == 0) break;
}
```

---

## 📌 주요 상수 및 참고

### Datagrid 컬럼 (InsungsAct_RcptRegPage.cs Line 88-90)
- `c_nCol상태 = 1`
- `c_nCol주문번호 = 2`

### Datagrid 구조
- y=0: 헤더
- y=1: 빈 행 (Empty Row)
- y=2~: 데이터 행

### 대기 시간
- `c_nWaitShort`: 짧은 대기
- `c_nWaitNormal`: 보통 대기
- `c_nWaitLong = 250ms`: 긴 대기

### 재시도 횟수
- `c_nRepeatShort = 3`: 3회 재시도

---

## 🔗 최근 커밋

- `f78e473` - feat: ReEnqueue 함수 개선 및 Skip case 처리 추가
- `f99e928` - feat: Region 5-3 페이지별 검색 루프 구조 구현
- `40a2161` - feat: Region 5-1, 5-2 구현 (기존 주문 관리)
- `caad2f6` - feat: SignalR로 Kai DB Insung1 업데이트 구현

---

**최종 업데이트**: 2025-11-03
